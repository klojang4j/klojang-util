<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StringMethods.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Klojang Util</a> &gt; <a href="index.source.html" class="el_package">org.klojang.util</a> &gt; <span class="el_source">StringMethods.java</span></div><h1>StringMethods.java</h1><pre class="source lang-java linenums">package org.klojang.util;

import org.klojang.check.Check;
import org.klojang.util.collection.IntList;

import java.util.*;

import static java.lang.Character.toLowerCase;
import static org.klojang.check.CommonChecks.*;
import static org.klojang.check.CommonExceptions.indexOutOfBounds;
import static org.klojang.check.Tag.*;
import static org.klojang.util.InvokeMethods.getArrayLength;
import static org.klojang.util.MathMethods.divUp;
import static org.klojang.util.ObjectMethods.ifNull;
import static org.klojang.util.ObjectMethods.isEmpty;


/**
 * Methods for working with strings. Quite a few methods in this class are geared
 * towards printing. They take an argument of type {@code Object}, rather than
 * {@code String}. If the argument is {@code null}, they will return an empty string,
 * else they will call {@code toString()} on the argument and then manipulate the
 * resulting {@code String}. They are null-safe and they will never return
 * {@code null} themselves. The parameter name for the {@code Object} argument will
 * be &quot;input&quot;. For ease of reading the {@code input} parameter will still be referred
 * to as a {@code String}.
 */
public final class StringMethods {

  /**
   * The empty string.
   */
  public static final String EMPTY_STRING = &quot;&quot;;

  private StringMethods() {}

  /**
   * Appends the specified value to the specified {@code StringBuilder} and returns
   * the {@code StringBuilder}.
   *
   * @param sb the {@code StringBuilder} to append the value to
   * @param val The value to append
   * @return the {@code StringBuilder}
   */
  public static StringBuilder append(StringBuilder sb, Object val) {
<span class="fc" id="L46">    return Check.notNull(sb, &quot;sb&quot;).ok().append(val);</span>
  }

  /**
   * Appends the specified values to the specified {@code StringBuilder} and returns
   * the {@code StringBuilder}.
   *
   * @param sb the {@code StringBuilder} to append the values to
   * @param val0 a value
   * @param val1 another value
   * @return the {@code StringBuilder}
   */
  public static StringBuilder append(StringBuilder sb, Object val0, Object val1) {
<span class="fc" id="L59">    return Check.notNull(sb, &quot;sb&quot;).ok().append(val0).append(val1);</span>
  }

  /**
   * Appends the specified values to the specified {@code StringBuilder} and returns
   * the {@code StringBuilder}.
   *
   * @param sb the {@code StringBuilder} to append the values to
   * @param val0 a value
   * @param val1 another value
   * @param val2 another value
   * @return the {@code StringBuilder}
   */
  public static StringBuilder append(StringBuilder sb,
      Object val0,
      Object val1,
      Object val2) {
<span class="fc" id="L76">    return Check.notNull(sb, &quot;sb&quot;).ok().append(val0).append(val1).append(val2);</span>
  }

  /**
   * Appends the specified values to the specified {@code StringBuilder} and returns
   * the {@code StringBuilder}.
   *
   * @param sb the {@code StringBuilder} to append the values to
   * @param val0 a value
   * @param val1 another value
   * @param val2 another value
   * @param val3 another value
   * @return the {@code StringBuilder}
   */
  public static StringBuilder append(
      StringBuilder sb, Object val0, Object val1, Object val2, Object val3) {
<span class="fc" id="L92">    return Check.notNull(sb, &quot;sb&quot;)</span>
<span class="fc" id="L93">        .ok()</span>
<span class="fc" id="L94">        .append(val0)</span>
<span class="fc" id="L95">        .append(val1)</span>
<span class="fc" id="L96">        .append(val2)</span>
<span class="fc" id="L97">        .append(val3);</span>
  }

  /**
   * Appends the specified values to the specified {@code StringBuilder} and returns
   * the {@code StringBuilder}.
   *
   * @param sb the {@code StringBuilder} to append the values to
   * @param val0 a value
   * @param val1 another value
   * @param val2 another value
   * @param val3 another value
   * @param val4 another value
   * @return the {@code StringBuilder}
   */
  public static StringBuilder append(
      StringBuilder sb,
      Object val0,
      Object val1,
      Object val2,
      Object val3,
      Object val4) {

<span class="fc" id="L120">    return Check.notNull(sb, &quot;sb&quot;)</span>
<span class="fc" id="L121">        .ok()</span>
<span class="fc" id="L122">        .append(val0)</span>
<span class="fc" id="L123">        .append(val1)</span>
<span class="fc" id="L124">        .append(val2)</span>
<span class="fc" id="L125">        .append(val3)</span>
<span class="fc" id="L126">        .append(val4);</span>
  }

  /**
   * Appends the specified values to the specified {@code StringBuilder} and returns
   * the {@code StringBuilder}.
   *
   * @param sb the {@code StringBuilder} to append the values to
   * @param val0 a value
   * @param val1 another value
   * @param val2 another value
   * @param val3 another value
   * @param val4 another value
   * @param val5 another value
   * @return the {@code StringBuilder}
   */
  public static StringBuilder append(
      StringBuilder sb,
      Object val0,
      Object val1,
      Object val2,
      Object val3,
      Object val4,
      Object val5) {

<span class="fc" id="L151">    return Check.notNull(sb, &quot;sb&quot;)</span>
<span class="fc" id="L152">        .ok()</span>
<span class="fc" id="L153">        .append(val0)</span>
<span class="fc" id="L154">        .append(val1)</span>
<span class="fc" id="L155">        .append(val2)</span>
<span class="fc" id="L156">        .append(val3)</span>
<span class="fc" id="L157">        .append(val4)</span>
<span class="fc" id="L158">        .append(val5);</span>
  }

  /**
   * Appends the specified values to the specified {@code StringBuilder} and returns
   * the {@code StringBuilder}.
   *
   * @param sb the {@code StringBuilder} to append the values to
   * @param val0 a value
   * @param val1 another value
   * @param val2 another value
   * @param val3 another value
   * @param val4 another value
   * @param val5 another value
   * @param val6 another value
   * @return the {@code StringBuilder}
   */
  public static StringBuilder append(
      StringBuilder sb,
      Object val0,
      Object val1,
      Object val2,
      Object val3,
      Object val4,
      Object val5,
      Object val6) {

<span class="fc" id="L185">    return Check.notNull(sb, &quot;sb&quot;)</span>
<span class="fc" id="L186">        .ok()</span>
<span class="fc" id="L187">        .append(val0)</span>
<span class="fc" id="L188">        .append(val1)</span>
<span class="fc" id="L189">        .append(val2)</span>
<span class="fc" id="L190">        .append(val3)</span>
<span class="fc" id="L191">        .append(val4)</span>
<span class="fc" id="L192">        .append(val5)</span>
<span class="fc" id="L193">        .append(val6);</span>
  }

  /**
   * Appends the specified values to the specified {@code StringBuilder} and returns
   * the {@code StringBuilder}.
   *
   * @param sb the {@code StringBuilder} to append the values to
   * @param val0 a value
   * @param val1 another value
   * @param val2 another value
   * @param val3 another value
   * @param val4 another value
   * @param val5 another value
   * @param val6 another value
   * @param val7 another value
   * @return the {@code StringBuilder}
   */
  public static StringBuilder append(
      StringBuilder sb,
      Object val0,
      Object val1,
      Object val2,
      Object val3,
      Object val4,
      Object val5,
      Object val6,
      Object val7) {

<span class="fc" id="L222">    return Check.notNull(sb, &quot;sb&quot;)</span>
<span class="fc" id="L223">        .ok()</span>
<span class="fc" id="L224">        .append(val0)</span>
<span class="fc" id="L225">        .append(val1)</span>
<span class="fc" id="L226">        .append(val2)</span>
<span class="fc" id="L227">        .append(val3)</span>
<span class="fc" id="L228">        .append(val4)</span>
<span class="fc" id="L229">        .append(val5)</span>
<span class="fc" id="L230">        .append(val6)</span>
<span class="fc" id="L231">        .append(val7);</span>
  }

  /**
   * Appends the specified values to the specified {@code StringBuilder} and returns
   * the {@code StringBuilder}.
   *
   * @param sb the {@code StringBuilder} to append the values to
   * @param val0 a value
   * @param val1 another value
   * @param val2 another value
   * @param val3 another value
   * @param val4 another value
   * @param val5 another value
   * @param val6 another value
   * @param val7 another value
   * @param val8 another value
   * @return the {@code StringBuilder}
   */
  public static StringBuilder append(
      StringBuilder sb,
      Object val0,
      Object val1,
      Object val2,
      Object val3,
      Object val4,
      Object val5,
      Object val6,
      Object val7,
      Object val8) {

<span class="fc" id="L262">    return Check.notNull(sb, &quot;sb&quot;)</span>
<span class="fc" id="L263">        .ok()</span>
<span class="fc" id="L264">        .append(val0)</span>
<span class="fc" id="L265">        .append(val1)</span>
<span class="fc" id="L266">        .append(val2)</span>
<span class="fc" id="L267">        .append(val3)</span>
<span class="fc" id="L268">        .append(val4)</span>
<span class="fc" id="L269">        .append(val5)</span>
<span class="fc" id="L270">        .append(val6)</span>
<span class="fc" id="L271">        .append(val7)</span>
<span class="fc" id="L272">        .append(val8);</span>
  }

  /**
   * Appends the specified values to the specified {@code StringBuilder} and returns
   * the {@code StringBuilder}.
   *
   * @param sb the {@code StringBuilder} to append the values to
   * @param val0 a value
   * @param val1 another value
   * @param val2 another value
   * @param val3 another value
   * @param val4 another value
   * @param val5 another value
   * @param val6 another value
   * @param val7 another value
   * @param val8 another value
   * @param val9 another value
   * @param moreData more values
   * @return the {@code StringBuilder}
   */
  public static StringBuilder append(
      StringBuilder sb,
      Object val0,
      Object val1,
      Object val2,
      Object val3,
      Object val4,
      Object val5,
      Object val6,
      Object val7,
      Object val8,
      Object val9,
      Object... moreData) {

<span class="fc" id="L307">    Check.notNull(sb, &quot;sb&quot;)</span>
<span class="fc" id="L308">        .ok()</span>
<span class="fc" id="L309">        .append(val0)</span>
<span class="fc" id="L310">        .append(val1)</span>
<span class="fc" id="L311">        .append(val2)</span>
<span class="fc" id="L312">        .append(val3)</span>
<span class="fc" id="L313">        .append(val4)</span>
<span class="fc" id="L314">        .append(val5)</span>
<span class="fc" id="L315">        .append(val6)</span>
<span class="fc" id="L316">        .append(val7)</span>
<span class="fc" id="L317">        .append(val8)</span>
<span class="fc" id="L318">        .append(val9);</span>
<span class="fc" id="L319">    Check.notNull(moreData, &quot;val&quot;).ok(Arrays::stream).forEach(sb::append);</span>
<span class="fc" id="L320">    return sb;</span>
  }

  /**
   * Concatenates the specified data.
   *
   * @param data the data to append (must not be null)
   * @return the concatenation of the data
   */
  public static String concat(Object... data) {
<span class="fc" id="L330">    Check.notNull(data);</span>
<span class="fc" id="L331">    StringBuilder sb = new StringBuilder(10 * data.length);</span>
<span class="fc" id="L332">    Arrays.stream(data).forEach(sb::append);</span>
<span class="fc" id="L333">    return sb.toString();</span>
  }

  /**
   * Counts the number of occurrences of {@code substr} within {@code input}. Returns
   * 0 (zero) if {@code input} is {@code null}.
   *
   * @param input the string to search
   * @param substr the substring to search for (must not be {@code null} or
   *     empty)
   * @return the number of occurrences of {@code substr} within {@code input}
   */
  public static int count(Object input, String substr) {
<span class="fc" id="L346">    return count(input, substr, false);</span>
  }

  /**
   * Counts the number of occurrences of {@code substr} within {@code input}. Returns
   * 0 (zero) if {@code input} is {@code null}.
   *
   * @param input the string to search
   * @param substr the substring to search for (must not be {@code null} or
   *     empty)
   * @param ignoreCase whether to ignore case while comparing substrings
   * @return the number of occurrences of {@code substr} within {@code input}
   */
  public static int count(Object input, String substr, boolean ignoreCase) {
<span class="fc" id="L360">    return count(input, substr, ignoreCase, 0);</span>
  }

  /**
   * Counts the number of occurrences of {@code substr} within {@code input}. Returns
   * 0 (zero) if {@code input} is {@code null}.
   *
   * @param input the string to search
   * @param substr the substring to search for (must not be {@code null} or
   *     empty)
   * @param ignoreCase whether to ignore case while comparing substrings
   * @param limit the maximum number of occurrences the count. You may specify 0
   *     (zero) for &quot;no maximum&quot;.
   * @return the number of occurrences of {@code substr} within {@code input} (will
   *     not exceed {@code limit})
   */
  public static int count(Object input,
      String substr,
      boolean ignoreCase,
      int limit) {
<span class="fc" id="L380">    Check.that(substr, &quot;substr&quot;).isNot(empty());</span>
<span class="fc" id="L381">    Check.that(limit, &quot;limit&quot;).is(gte(), 0);</span>
    String str;
<span class="fc bfc" id="L383" title="All 4 branches covered.">    if (input == null || (str = input.toString()).length() &lt; substr.length()) {</span>
<span class="fc" id="L384">      return 0;</span>
    }
<span class="fc bfc" id="L386" title="All 2 branches covered.">    if (substr.length() == 1) {</span>
<span class="fc" id="L387">      return count(str, substr.charAt(0), ignoreCase, limit);</span>
    }
<span class="fc" id="L389">    int count = 0;</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">    for (int i = 0; i &lt;= str.length() - substr.length(); ++i) {</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">      if (str.regionMatches(ignoreCase, i, substr, 0, substr.length())) {</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">        if (++count == limit) {</span>
<span class="fc" id="L393">          break;</span>
        }
      }
    }
<span class="fc" id="L397">    return count;</span>
  }

  /**
   * Counts the number of non-overlapping occurrences of {@code substr} within
   * {@code input}. The string to search for must not be null or empty and is not
   * treated as a regular expression. Returns 0 (zero) if {@code input} is
   * {@code null}.
   *
   * @param input the string to search
   * @param substr the substring to search for
   * @return the number of non-overlapping occurrences of {@code substr} within
   *     {@code input}
   */
  public static int countDiscrete(Object input, String substr) {
<span class="fc" id="L412">    return countDiscrete(input, substr, false, 0);</span>
  }

  /**
   * Counts the number of non-overlapping occurrences of {@code substr} within
   * {@code input}. The string to search for must not be null or empty and is not
   * treated as a regular expression. Returns 0 (zero) if {@code input} is
   * {@code null}.
   *
   * @param input the string to search
   * @param substr the substring to search for
   * @param ignoreCase whether to ignore case while comparing substrings
   * @return the number of non-overlapping occurrences of {@code substr} within
   *     {@code input}
   */
  public static int countDiscrete(Object input,
      String substr,
      boolean ignoreCase) {
<span class="fc" id="L430">    return countDiscrete(input, substr, ignoreCase, 0);</span>
  }

  /**
   * Counts the number of non-overlapping occurrences of {@code substr} within
   * {@code input}. Returns 0 (zero) if {@code input} is {@code null}.
   *
   * @param input the string to search
   * @param substr the substring to search for
   * @param ignoreCase whether to ignore case while comparing substrings
   * @param limit the maximum number of occurrences the count. You may specify 0
   *     (zero) for &quot;no maximum&quot;.
   * @return the number of non-overlapping occurrences of {@code substr} within
   *     {@code input} (will not exceed {@code limit})
   */
  public static int countDiscrete(Object input,
      String substr,
      boolean ignoreCase,
      int limit) {
<span class="fc" id="L449">    Check.that(substr, &quot;substr&quot;).isNot(empty());</span>
<span class="fc" id="L450">    Check.that(limit, &quot;limit&quot;).is(gte(), 0);</span>
    String str;
<span class="fc bfc" id="L452" title="All 4 branches covered.">    if (input == null || (str = input.toString()).length() &lt; substr.length()) {</span>
<span class="fc" id="L453">      return 0;</span>
    }
<span class="fc bfc" id="L455" title="All 2 branches covered.">    if (substr.length() == 1) {</span>
<span class="fc" id="L456">      return count(str, substr.charAt(0), ignoreCase, limit);</span>
    }
<span class="fc" id="L458">    int count = 0;</span>
<span class="fc" id="L459">    int i = 0;</span>
    do {
<span class="fc bfc" id="L461" title="All 2 branches covered.">      if (str.regionMatches(ignoreCase, i, substr, 0, substr.length())) {</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">        if (++count == limit) {</span>
<span class="fc" id="L463">          break;</span>
        }
<span class="fc" id="L465">        i += substr.length();</span>
      } else {
<span class="fc" id="L467">        i += 1;</span>
      }
<span class="fc bfc" id="L469" title="All 2 branches covered.">    } while (i &lt;= str.length() - substr.length());</span>
<span class="fc" id="L470">    return count;</span>
  }

  private static int count(String str, char c, boolean ignoreCase, int limit) {
<span class="fc" id="L474">    int count = 0;</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">    if (ignoreCase) {</span>
<span class="fc" id="L476">      char c0 = toLowerCase(c);</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">      for (int i = 0; i &lt; str.length(); ++i) {</span>
<span class="pc bpc" id="L478" title="1 of 4 branches missed.">        if (toLowerCase(str.charAt(i)) == c0 &amp;&amp; ++count == limit) {</span>
<span class="fc" id="L479">          break;</span>
        }
      }
<span class="fc" id="L482">    } else {</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">      for (int i = 0; i &lt; str.length(); ++i) {</span>
<span class="fc bfc" id="L484" title="All 4 branches covered.">        if (str.charAt(i) == c &amp;&amp; ++count == limit) {</span>
<span class="fc" id="L485">          break;</span>
        }
      }
    }
<span class="fc" id="L489">    return count;</span>
  }

  /**
   * Returns {@code input.toString()} if its length does not exceed {@code maxWidth},
   * else truncates the string and appends &quot;...&quot;, such that the new string's length
   * does not exceed {@code maxWidth}. The lower bound for {@code maxWidth} will
   * tacitly be clamped to 4, so that at least one letter of the string is
   * displayed.
   *
   * &lt;h4&gt;Examples:&lt;/h4&gt;
   *
   * &lt;p&gt;
   *
   * &lt;pre&gt;
   * String hello = &quot;Hello World, how are you?&quot;;
   * assertEquals(&quot;Hello W...&quot;, ellipsis(hello, 10));
   * assertEquals(&quot;H...&quot;, ellipsis(hello, 4));
   * assertEquals(hello, ellipsis(hello, 100));
   * &lt;/pre&gt;
   *
   * @param input the string to abbreviate, if necessary
   * @param maxWidth the maximum width of the string (must be greater than 3)
   * @return the string itself or an abbreviated version, suffixed with &quot;...&quot;
   */
  public static String ellipsis(Object input, int maxWidth) {
<span class="fc bfc" id="L515" title="All 2 branches covered.">    if (input != null) {</span>
<span class="fc" id="L516">      return ellipsis0(input.toString(), maxWidth);</span>
    }
<span class="fc" id="L518">    return EMPTY_STRING;</span>
  }

  /**
   * Returns a short string representation of an object. Equivalent to
   * {@link #toShortString(Object, int) toShortString(obj, 50)}.
   *
   * @param obj the object to stringify
   * @return a string consisting of no more than 50 characters
   */
  public static String toShortString(Object obj) {
<span class="fc" id="L529">    return toShortString(obj, 50);</span>
  }

  /**
   * Returns a short string representation of an object. Roughly equivalent to
   * {@link #toShortString(Object, int, int, int) toShortString(obj, maxWidth,
   * maxWidth/8, maxWidth/16)}.
   *
   * @param obj the object to stringify
   * @param maxWidth the maximum width of the returned string
   * @return a string whose length will not exceed {@code maxWidth}
   */
  public static String toShortString(Object obj, int maxWidth) {
<span class="fc" id="L542">    int maxElements = divUp(maxWidth, 8);</span>
<span class="fc" id="L543">    int maxEntries = divUp(maxWidth, 16);</span>
<span class="fc" id="L544">    return toShortString(obj, maxWidth, maxElements, maxEntries);</span>
  }

  /**
   * Returns a short string representation of an object. Broadly speaking, this
   * method behaves as follows:
   * &lt;ul&gt;
   *   &lt;li&gt;if {@code obj} is {@code null}, it is stringified to &quot;null&quot;.
   *   &lt;li&gt;if {@code obj} is a {@code Class} object, it is stringified using
   *   {@link ClassMethods#simpleClassName(Class) ClassMethods.simpleClassName}.
   *   &lt;li&gt;if {@code obj} is a {@code Collection}, it is stringified as though by
   *   calling {@code toString()} on the collection after all but the first
   *   &lt;b&gt;{@code maxElements}&lt;/b&gt; elements have been removed from it. (This prevents
   *   collections from blowing up into huge strings, only for them to be truncated
   *   to {@code maxWidth} again. So there is both a performance aspect and a
   *   security aspect to making the maximum number of elements user-definable.)
   *   &lt;li&gt;if {@code obj} is an array, it is stringified as though by calling
   *   {@link Arrays#deepToString(Object[]) Arrays.deepToString} on it after all but
   *   the first &lt;b&gt;{@code maxElements}&lt;/b&gt; elements have been removed from it.
   *   &lt;li&gt;if {@code obj} is a {@code Map}, it is stringified as though by calling
   *   {@code toString()} on the collection after all but the first
   *   &lt;b&gt;{@code maxEntries}&lt;/b&gt; entries have been removed from it.
   *   &lt;li&gt;Otherwise {@code obj} is stringified simply by calling {@code toString}
   *   on it.
   * &lt;/ul&gt;
   * &lt;p&gt;
   * The resulting string is then truncated to &lt;b&gt;{@code maxWidth}&lt;/b&gt; as though by
   * calling {@link #ellipsis(Object, int) ellipsis} on it.
   * &lt;p&gt;
   * &lt;i&gt;You &lt;b&gt;should not&lt;/b&gt; rely on the exact appearance of the returned
   * string.&lt;/i&gt; Future implementations may produce slightly different strings for
   * the same object. (For example, they might give special treatment to certain
   * other types of objects.) The only stated aim of this method is to provide a
   * &lt;i&gt;length-constrained&lt;/i&gt; string representation of an object. The exact contents
   * of the returned string is unspecified.
   *
   * @param obj the object to stringify
   * @param maxWidth the maximum width of the returned string
   * @param maxElements the maximum number of elements to process if the argument
   *     is an array or {@code Collection}.
   * @param maxEntries the maximum number of entries to process if the argument
   *     is a {@code Map}.
   * @return a string whose length will not exceed {@code maxWidth}
   */
  public static String toShortString(Object obj,
      int maxWidth,
      int maxElements,
      int maxEntries) {
    // Don't use nl.naturalis.check here, as that package heavily relies on this
    // method again.
<span class="pc bpc" id="L594" title="3 of 6 branches missed.">    if (maxWidth &lt; 0 || maxElements &lt; 0 || maxEntries &lt; 0) {</span>
<span class="nc" id="L595">      throw new IllegalArgumentException(</span>
          &quot;maxWidth, maxElements and maxEntries must all be positive&quot;);
    }
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">    if (obj == null) {</span>
<span class="nc" id="L599">      return &quot;null&quot;;</span>
<span class="fc bfc" id="L600" title="All 4 branches covered.">    } else if (obj.getClass() == String.class || obj instanceof Number) {</span>
      // identify strings and numbers as quickly as possible, even though we will
      // end up calling obj.toString() again
<span class="fc" id="L603">      return ellipsis0(obj.toString(), maxWidth);</span>
    }
    String s;
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">    if (obj instanceof Class&lt;?&gt; c) {</span>
<span class="nc" id="L607">      s = ClassMethods.simpleClassName(c);</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">    } else if (obj instanceof Collection&lt;?&gt; c) {</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">      String x = c.size() &gt; maxElements ? &quot;, ...]&quot; : &quot;]&quot;;</span>
      //@formatter:off
<span class="fc" id="L611">      s = '[' + CollectionMethods.implode(c, o -&gt; toShortString(o, maxWidth, maxElements, maxEntries), &quot;, &quot;, 0, maxElements) + x;</span>
      //@formatter:ons
<span class="fc bfc" id="L613" title="All 2 branches covered.">    } else if (obj instanceof Map&lt;?, ?&gt; m) {</span>
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">      String x = m.size() &gt; maxElements ? &quot;, ...}&quot; : &quot;}&quot;;</span>
      //@formatter:off
<span class="fc" id="L616">      s = '{' + CollectionMethods.implode(m.entrySet(), o -&gt; toShortString(o, maxWidth, maxElements, maxEntries), &quot;, &quot;, 0, maxEntries) + x;</span>
      //@formatter:ons
<span class="fc bfc" id="L618" title="All 2 branches covered.">    } else if (obj instanceof Map.Entry&lt;?, ?&gt; e) {</span>
      //@formatter:off
<span class="fc" id="L620">      s = toShortString(e.getKey(), maxWidth, maxElements, maxEntries) + '=' + toShortString(e.getValue(), maxWidth, maxElements, maxEntries);</span>
      //@formatter:ons
<span class="fc bfc" id="L622" title="All 2 branches covered.">    } else if (obj instanceof int[] ints) {</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">      String x = ints.length &gt; maxElements ? &quot;, ...]&quot; : &quot;]&quot;;</span>
      //@formatter:off
<span class="fc" id="L625">      s = '['+ ArrayMethods.implodeInts((int[])obj, String::valueOf, &quot;, &quot;, 0, maxElements) + x;</span>
      //@formatter:on
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">    } else if (obj instanceof Object[] objs) {</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">      String x = objs.length &gt; maxElements ? &quot;, ...]&quot; : &quot;]&quot;;</span>
      //@formatter:off
<span class="nc" id="L630">      s = '[' + ArrayMethods.implode(objs, o -&gt; toShortString(o, maxWidth, maxElements, maxEntries), &quot;, &quot;, 0, maxElements) + x;</span>
      //@formatter:on
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">    } else if (obj.getClass().isArray()) {</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">      String x = getArrayLength(obj) &gt; maxElements ? &quot;, ...]&quot; : &quot;]&quot;;</span>
      //@formatter:off
<span class="nc" id="L635">      s = '[' + ArrayMethods.implodeAny(obj, String::valueOf, &quot;, &quot;, 0, maxElements) + x;</span>
      //@formatter:on
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">    } else if (obj instanceof IntList il) {</span>
<span class="fc" id="L638">      int y = Math.min(il.size(), maxElements + 1);</span>
      //@formatter:off
<span class="fc" id="L640">      return toShortString(il.toArray(0, y), maxWidth, maxElements, maxEntries);</span>
      //@formatter:on
    } else {
<span class="nc" id="L643">      s = obj.toString();</span>
    }
<span class="fc" id="L645">    return ellipsis0(s, maxWidth);</span>
  }

  private static String ellipsis0(String str, int maxWidth) {
<span class="fc" id="L649">    maxWidth = Math.max(4, maxWidth);</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">    if (str.length() &gt; maxWidth) {</span>
<span class="fc" id="L651">      return str.substring(0, maxWidth - 3) + &quot;...&quot;;</span>
    }
<span class="fc" id="L653">    return str;</span>
  }

  /**
   * Determines whether {@code input} starts with any of the specified prefixes.
   * Returns an {@code Optional} containing the first prefix found to be equal to the
   * end of the string, or an empty {@code Optional} if the string does not end with
   * any of the specified prefixes.
   *
   * @param input the string to test
   * @param ignoreCase whether to ignore case
   * @param prefixes the prefixes to test
   * @return Returns an {@code Optional} containing the first prefix found to be
   *     equal to the end of the string, or an empty {@code Optional} if the string
   *     does not end with any of the specified prefixes.
   */
  public static Optional&lt;String&gt; startsWith(Object input,
      boolean ignoreCase,
      Collection&lt;String&gt; prefixes) {
<span class="fc" id="L672">    Check.notNull(prefixes, &quot;prefixes&quot;);</span>
<span class="fc" id="L673">    return startsWith(input, ignoreCase, prefixes.toArray(String[]::new));</span>
  }

  /**
   * Determines whether {@code input} starts with any of the specified prefixes.
   * Returns an {@code Optional} containing the first prefix found to be equal to the
   * end of the string, or an empty {@code Optional} if the string does not end with
   * any of the specified prefixes.
   *
   * @param input the string to test
   * @param ignoreCase whether to ignore case
   * @param prefixes the prefixes to test
   * @return Returns an {@code Optional} containing the first prefix found to be
   *     equal to the end of the string, or an empty {@code Optional} if the string
   *     does not end with any of the specified prefixes.
   */
  public static Optional&lt;String&gt; startsWith(Object input,
      boolean ignoreCase,
      String... prefixes) {
<span class="fc" id="L692">    Check.that(prefixes, &quot;prefixes&quot;).is(deepNotEmpty());</span>
<span class="fc bfc" id="L693" title="All 2 branches covered.">    if (input == null) {</span>
<span class="fc" id="L694">      return Optional.empty();</span>
    }
<span class="fc" id="L696">    return Optional.ofNullable(startsWith0(input.toString(), ignoreCase, prefixes));</span>
  }

  private static String startsWith0(String str,
      boolean ignoreCase,
      String[] prefixes) {
<span class="fc bfc" id="L702" title="All 2 branches covered.">    if (!isEmpty(str)) {</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">      for (String prefix : prefixes) {</span>
<span class="fc bfc" id="L704" title="All 2 branches covered.">        if (str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length())) {</span>
<span class="fc" id="L705">          return prefix;</span>
        }
      }
    }
<span class="fc" id="L709">    return null;</span>
  }

  /**
   * Determines whether {@code input} ends with any of the specified suffixes.
   * Returns an {@code Optional} containing the first suffix found to be equal to the
   * end of the string, or an empty {@code Optional} if the string does not end with
   * any of the specified suffixes.
   *
   * @param input the string to test
   * @param ignoreCase whether to ignore case
   * @param suffixes the suffixes to test
   * @return Returns an {@code Optional} containing the first suffix found to be
   *     equal to the end of the string, or an empty {@code Optional} if the string
   *     does not end with any of the specified suffixes.
   */
  public static Optional&lt;String&gt; endsWith(Object input,
      boolean ignoreCase,
      Collection&lt;String&gt; suffixes) {
<span class="fc" id="L728">    Check.notNull(suffixes, &quot;suffixes&quot;);</span>
<span class="fc" id="L729">    return endsWith(input, ignoreCase, suffixes.toArray(String[]::new));</span>
  }

  /**
   * Determines whether {@code input} ends with any of the specified suffixes.
   * Returns an {@code Optional} containing the first suffix found to be equal to the
   * end of the string, or an empty {@code Optional} if the string does not end with
   * any of the specified suffixes.
   *
   * @param input the string to test
   * @param ignoreCase whether to ignore case
   * @param suffixes the suffixes to test
   * @return Returns an {@code Optional} containing the first suffix found to be
   *     equal to the end of the string, or an empty {@code Optional} if the string
   *     does not end with any of the specified suffixes.
   */
  public static Optional&lt;String&gt; endsWith(Object input,
      boolean ignoreCase,
      String... suffixes) {
<span class="fc" id="L748">    Check.that(suffixes, &quot;suffixes&quot;).is(deepNotEmpty());</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">    if (input == null) {</span>
<span class="fc" id="L750">      return Optional.empty();</span>
    }
<span class="fc" id="L752">    return Optional.ofNullable(endsWith0(input.toString(), ignoreCase, suffixes));</span>
  }

  private static String endsWith0(String str,
      boolean ignoreCase,
      String[] suffixes) {
<span class="fc bfc" id="L758" title="All 2 branches covered.">    if (!isEmpty(str)) {</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">      for (String suffix : suffixes) {</span>
<span class="fc" id="L760">        int len = suffix.length();</span>
<span class="fc" id="L761">        int off = str.length() - len;</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">        if (str.regionMatches(ignoreCase, off, suffix, 0, len)) {</span>
<span class="fc" id="L763">          return suffix;</span>
        }
      }
    }
<span class="fc" id="L767">    return null;</span>
  }

  /**
   * Prefixes to specified prefix to {@code input} if it did not already start with
   * that prefix. Returns {@code prefix} if {@code input} is null,
   *
   * @param input the {@code String} to which to append the prefix
   * @param prefix the prefix (must not be {@code null})
   * @return a string that is guaranteed to start with {@code prefix}
   */
  public static String ensurePrefix(Object input, String prefix) {
<span class="fc" id="L779">    Check.notNull(prefix, &quot;prefix&quot;);</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">    if (input == null) {</span>
<span class="fc" id="L781">      return prefix;</span>
    }
<span class="fc" id="L783">    String str = input.toString();</span>
<span class="fc bfc" id="L784" title="All 2 branches covered.">    return str.startsWith(prefix) ? str : prefix + str;</span>
  }

  /**
   * Appends to specified suffix to {@code input} if it did not already have that
   * suffix. If {@code input} is null, {@code suffix} is returned.
   *
   * @param input the {@code String} to which to append the suffix
   * @param suffix the suffix (must not be {@code null})
   * @return a string that is guaranteed to end with {@code suffix}
   */
  public static String ensureSuffix(Object input, String suffix) {
<span class="fc" id="L796">    Check.notNull(suffix, &quot;suffix&quot;);</span>
<span class="fc bfc" id="L797" title="All 2 branches covered.">    if (input == null) {</span>
<span class="fc" id="L798">      return suffix;</span>
    }
<span class="fc" id="L800">    String str = input.toString();</span>
<span class="fc bfc" id="L801" title="All 2 branches covered.">    return str.endsWith(suffix) ? str : str + suffix;</span>
  }

  /**
   * Whether the specified string is null or blank.
   *
   * @param input the string
   * @return whether it is null or blank
   */
  public static boolean isBlank(Object input) {
<span class="fc bfc" id="L811" title="All 4 branches covered.">    return input == null || input.toString().isBlank();</span>
  }

  /**
   * Returns the 1st argument if it is not a whitespace-only string, else the 2nd
   * argument.
   *
   * @param input the string to return if not null
   * @param dfault the replacement string
   * @see ObjectMethods#ifNull(Object, Object)
   */
  public static String ifBlank(Object input, String dfault) {
<span class="fc bfc" id="L823" title="All 2 branches covered.">    return isBlank(input) ? dfault : input.toString();</span>
  }

  /**
   * Removes all occurrences of the specified prefixes from the start of a string.
   * The returned string will no longer start with any of the specified prefixes.
   *
   * @param input the string to remove the prefixes from
   * @param prefixes the prefixes to remove
   */
  public static String lchop(Object input, String... prefixes) {
<span class="fc" id="L834">    return lchop(input, false, prefixes);</span>
  }

  /**
   * Removes all occurrences of the specified prefixes from the start of a string.
   * The returned string will no longer start with any of the specified prefixes.
   *
   * @param input the string to remove the prefixes from
   * @param ignoreCase whether to ignore case
   * @param prefixes the prefixes to remove
   */
  public static String lchop(Object input,
      boolean ignoreCase,
      String... prefixes) {
<span class="fc" id="L848">    Check.that(prefixes, &quot;prefixes&quot;).is(deepNotEmpty());</span>
    String str;
<span class="fc bfc" id="L850" title="All 4 branches covered.">    if (input == null || (str = input.toString()).isEmpty()) {</span>
<span class="fc" id="L851">      return EMPTY_STRING;</span>
    }
    boolean found;
<span class="fc" id="L854">    int offset = 0;</span>
    do {
<span class="fc" id="L856">      found = false;</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">      for (String prefix : prefixes) {</span>
<span class="fc bfc" id="L858" title="All 2 branches covered.">        if (str.regionMatches(ignoreCase, offset, prefix, 0, prefix.length())) {</span>
<span class="fc" id="L859">          offset += prefix.length();</span>
<span class="fc" id="L860">          found = true;</span>
        }
      }
<span class="fc bfc" id="L863" title="All 2 branches covered.">    } while (found);</span>
<span class="fc" id="L864">    return str.substring(offset);</span>
  }

  /**
   * Removes all occurrences of the specified suffixes from the end of a string. The
   * returned string will no longer end with any of the specified suffixes.
   *
   * @param input the string to manipulate
   * @param suffixes the suffixes to chop off the right of the string
   * @return a String that does not end with any of the specified suffixes
   */
  public static String rchop(Object input, String... suffixes) {
<span class="fc" id="L876">    return rchop(input, false, suffixes);</span>
  }

  /**
   * Removes all occurrences of the specified suffixes from the end of a string. The
   * returned string will no longer end with any of the specified suffixes.
   *
   * @param input the string to manipulate
   * @param ignoreCase whether to ignore case while chopping off suffixes
   * @param suffixes a String that does not end with any of the specified
   *     suffixes
   */
  public static String rchop(Object input,
      boolean ignoreCase,
      String... suffixes) {
<span class="fc" id="L891">    Check.that(suffixes, &quot;suffixes&quot;).is(deepNotEmpty());</span>
    String str;
<span class="fc bfc" id="L893" title="All 4 branches covered.">    if (input == null || (str = input.toString()).isEmpty()) {</span>
<span class="fc" id="L894">      return EMPTY_STRING;</span>
    }
    boolean found;
<span class="fc" id="L897">    int offset = str.length();</span>
    do {
<span class="fc" id="L899">      found = false;</span>
<span class="fc bfc" id="L900" title="All 2 branches covered.">      for (String suffix : suffixes) {</span>
<span class="fc" id="L901">        int sl = suffix.length();</span>
<span class="fc bfc" id="L902" title="All 2 branches covered.">        if (str.regionMatches(ignoreCase, offset - sl, suffix, 0, sl)) {</span>
<span class="fc" id="L903">          offset -= sl;</span>
<span class="fc" id="L904">          found = true;</span>
        }
      }
<span class="fc bfc" id="L907" title="All 2 branches covered.">    } while (found);</span>
<span class="fc" id="L908">    return str.substring(0, offset);</span>
  }

  /**
   * Ensures that the first character of the specified string is not a lowercase
   * character.
   *
   * @param input the string
   * @return the same string except that the first character is not a lowercase
   *     character
   */
  public static String firstToUpper(Object input) {
    String s;
<span class="fc bfc" id="L921" title="All 4 branches covered.">    if (input == null || (s = input.toString()).isEmpty()) {</span>
<span class="fc" id="L922">      return EMPTY_STRING;</span>
    }
<span class="fc bfc" id="L924" title="All 2 branches covered.">    if (Character.isLowerCase(s.charAt(0))) {</span>
<span class="fc" id="L925">      return Character.toUpperCase(s.charAt(0)) + s.substring(1);</span>
    }
<span class="fc" id="L927">    return s;</span>
  }

  /**
   * Ensures that the first character of the specified string is not an uppercase
   * character.
   *
   * @param input the string
   * @return the same string except that the first character is not an uppercase
   *     character
   */
  public static String firstToLower(Object input) {
    String s;
<span class="fc bfc" id="L940" title="All 4 branches covered.">    if (input == null || (s = input.toString()).isEmpty()) {</span>
<span class="fc" id="L941">      return EMPTY_STRING;</span>
    }
<span class="fc bfc" id="L943" title="All 2 branches covered.">    if (Character.isUpperCase(s.charAt(0))) {</span>
<span class="fc" id="L944">      return Character.toLowerCase(s.charAt(0)) + s.substring(1);</span>
    }
<span class="fc" id="L946">    return s;</span>
  }

  /**
   * Left-pads a string to the specified width using the space character (' ').
   *
   * @param input an object whose {@code toString()} method produces the string
   *     to be padded. Null is treated as the empty string.
   * @param width the total length of the padded string. If the string itself is
   *     wider than the specified width, the string is returned without padding.
   * @return the left-padded string
   */
  public static String lpad(Object input, int width) {
<span class="fc" id="L959">    return lpad(input, width, ' ', EMPTY_STRING);</span>
  }

  /**
   * Left-pads a string to the specified width using the specified padding
   * character.
   *
   * @param input an object whose {@code toString()} method produces the string
   *     to be padded. Null is treated as the empty string.
   * @param width the total length of the padded string. If the string itself is
   *     wider than the specified width, the string is returned without padding.
   * @param padChar the character used to left-pad the string
   * @return the left-padded string
   */
  public static String lpad(Object input, int width, char padChar) {
<span class="fc" id="L974">    return lpad(input, width, padChar, EMPTY_STRING);</span>
  }

  /**
   * Left-pads a string to the specified width using the specified padding character
   * and then appends the specified terminator.
   *
   * @param input an object whose {@code toString()} method produces the string
   *     to be padded. Null is treated as the empty string.
   * @param width the total length of the padded string. If the string itself is
   *     wider than the specified width, the string is returned without padding.
   * @param padChar the character used to left-pad the string
   * @param delimiter a delimiter to append to the padded string. Specify null or
   *     an empty string to indicate that no delimiter should be appended.
   * @return the left-padded string
   * @throws IllegalArgumentException If {@code terminator} is null
   */
  public static String lpad(Object input,
      int width,
      char padChar,
      String delimiter) {
<span class="fc" id="L995">    Check.that(width, &quot;width&quot;).is(gte(), 0);</span>
<span class="fc bfc" id="L996" title="All 2 branches covered.">    String s = input == null ? EMPTY_STRING : input.toString();</span>
<span class="fc" id="L997">    String d = ifNull(delimiter, EMPTY_STRING);</span>
<span class="fc bfc" id="L998" title="All 2 branches covered.">    if (s.length() &gt;= width) {</span>
<span class="fc" id="L999">      return s + d;</span>
    }
<span class="fc" id="L1001">    return new StringBuilder(width + d.length())</span>
<span class="fc" id="L1002">        .append(String.valueOf(padChar).repeat(width - s.length()))</span>
<span class="fc" id="L1003">        .append(s)</span>
<span class="fc" id="L1004">        .append(d)</span>
<span class="fc" id="L1005">        .toString();</span>
  }

  /**
   * Centers (left- and right-pads) a string within the specified width using the
   * space character.
   *
   * @param input an object whose {@code toString()} method produces the string
   *     to be padded. Null is treated as the empty string.
   * @param width the total length of the padded string. If the string itself is
   *     wider than the specified width, the string is printed without padding.
   * @return the left- and right-padded string plus the terminator
   */
  public static String pad(Object input, int width) {
<span class="fc" id="L1019">    return pad(input, width, ' ', null);</span>
  }

  /**
   * Centers (left- and right-pads) a string within the specified width using the
   * specified padding character.
   *
   * @param input an object whose {@code toString()} method produces the string
   *     to be padded. Null is treated as the empty string.
   * @param width the total length of the padded string. If the string itself is
   *     wider than the specified width, the string is printed without padding.
   * @param padChar the character used to left- and right-pad the string.
   * @return the left- and right-padded string plus the terminator
   */
  public static String pad(Object input, int width, char padChar) {
<span class="fc" id="L1034">    return pad(input, width, padChar, null);</span>
  }

  /**
   * Centers (left- and right-pads) a string within the specified width using the
   * specified padding character and then appends the specified delimiter.
   *
   * @param input an object whose {@code toString()} method produces the string
   *     to be padded. Null is treated as the empty string.
   * @param width the total length of the padded string. If the string itself is
   *     wider than the specified width, the string is printed without padding.
   * @param padChar the character used to left- and right-pad the string.
   * @param delimiter a delimiter to append to the padded string. Specify null or
   *     an empty string to indicate that no delimiter should be appended.
   * @return the left- and right-padded string plus the terminator
   */
  public static String pad(Object input,
      int width,
      char padChar,
      String delimiter) {
<span class="fc" id="L1054">    Check.that(width, &quot;width&quot;).is(gte(), 0);</span>
<span class="fc bfc" id="L1055" title="All 2 branches covered.">    String s = input == null ? EMPTY_STRING : input.toString();</span>
<span class="fc" id="L1056">    String d = ifNull(delimiter, EMPTY_STRING);</span>
<span class="fc bfc" id="L1057" title="All 2 branches covered.">    if (s.length() &gt;= width) {</span>
<span class="fc" id="L1058">      return s + d;</span>
    }
<span class="fc" id="L1060">    StringBuilder sb = new StringBuilder(width + d.length());</span>
<span class="fc" id="L1061">    int left = (width - s.length()) / 2;</span>
<span class="fc" id="L1062">    int right = width - left - s.length();</span>
<span class="fc" id="L1063">    sb.append(String.valueOf(padChar).repeat(left));</span>
<span class="fc" id="L1064">    sb.append(s);</span>
<span class="fc" id="L1065">    sb.append(String.valueOf(padChar).repeat(Math.max(0, right)));</span>
<span class="fc" id="L1066">    sb.append(d);</span>
<span class="fc" id="L1067">    return sb.toString();</span>
  }

  /**
   * Right-pads a string to the specified width using the space character (' ').
   *
   * @param input an object whose {@code toString()} method produces the string
   *     to be padded. Null is treated as the empty string.
   * @param width the total length of the padded string. If the string itself is
   *     wider than the specified width, the string is returned without padding.
   * @return the right-padded string
   */
  public static String rpad(Object input, int width) {
<span class="fc" id="L1080">    return rpad(input, width, ' ', EMPTY_STRING);</span>
  }

  /**
   * Right-pads a string to the specified width using the specified padding
   * character.
   *
   * @param input an object whose {@code toString()} method produces the string
   *     to be padded. Null is treated as the empty string.
   * @param width the total length of the padded string. If the string itself is
   *     wider than the specified width, the string is returned without padding.
   * @param padChar the character used to left-pad the string.
   * @return the right-padded string
   */
  public static String rpad(Object input, int width, char padChar) {
<span class="fc" id="L1095">    return rpad(input, width, padChar, EMPTY_STRING);</span>
  }

  /**
   * Right-pads a string to the specified width using the specified padding character
   * and appends the specified suffix.
   *
   * @param input an object whose {@code toString()} method produces the string
   *     to be padded. Null is treated as the empty string.
   * @param width the total length of the padded string. If the string itself is
   *     wider than the specified width, the string is printed without padding.
   * @param padChar the character used to right-pad the string.
   * @param suffix A suffix to append to the padded string.
   * @return the right-padded string
   */
  public static String rpad(Object input, int width, char padChar, String suffix) {
<span class="fc" id="L1111">    Check.that(width, &quot;width&quot;).is(gte(), 0);</span>
<span class="fc" id="L1112">    Check.notNull(suffix, &quot;delimiter&quot;);</span>
<span class="fc bfc" id="L1113" title="All 2 branches covered.">    String str = input == null ? EMPTY_STRING : input.toString();</span>
<span class="fc bfc" id="L1114" title="All 2 branches covered.">    if (str.length() &gt;= width) {</span>
<span class="fc" id="L1115">      return str + suffix;</span>
    }
<span class="fc" id="L1117">    StringBuilder sb = new StringBuilder(width + suffix.length());</span>
<span class="fc" id="L1118">    String padding = String.valueOf(padChar);</span>
<span class="fc" id="L1119">    return append(sb, str, padding.repeat(width - str.length()), suffix).toString();</span>
  }

  /**
   * Left-trims all characters contained in {@code chars} from the specified string.
   * The resulting string will not start with any of the characters contained in
   * {@code chars}.
   *
   * @param input the {@code String} to trim
   * @param chars the character to trim off the {@code String}
   * @return the left-trimmed {@code String} or the input string if it did not start
   *     with any of the specified characters
   */
  public static String ltrim(Object input, String chars) {
<span class="fc" id="L1133">    Check.that(chars, &quot;chars&quot;).isNot(empty());</span>
<span class="fc bfc" id="L1134" title="All 2 branches covered.">    if (input == null) {</span>
<span class="fc" id="L1135">      return EMPTY_STRING;</span>
    }
<span class="fc" id="L1137">    String str = input.toString();</span>
<span class="fc" id="L1138">    int i = 0;</span>
    LOOP:
<span class="fc bfc" id="L1140" title="All 2 branches covered.">    for (; i &lt; str.length(); ++i) {</span>
<span class="fc bfc" id="L1141" title="All 2 branches covered.">      for (int j = 0; j &lt; chars.length(); ++j) {</span>
<span class="fc bfc" id="L1142" title="All 2 branches covered.">        if (str.charAt(i) == chars.charAt(j)) {</span>
<span class="fc" id="L1143">          continue LOOP;</span>
        }
      }
<span class="fc" id="L1146">      break;</span>
    }
<span class="fc bfc" id="L1148" title="All 2 branches covered.">    return i == 0 ? str : str.substring(i);</span>
  }

  /**
   * Right-trims all characters contained in {@code chars} from the specified string.
   * The resulting string will not end with any of the characters contained in
   * {@code chars}.
   *
   * @param input the {@code String} to trim
   * @param chars the character to trim off the {@code String} (must not be
   *     {@code null} or empty)
   * @return the right-trimmed {@code String} or the input string if it did not end
   *     with any of the specified characters
   */
  public static String rtrim(Object input, String chars) {
<span class="fc" id="L1163">    Check.that(chars, &quot;chars&quot;).isNot(empty());</span>
<span class="fc bfc" id="L1164" title="All 2 branches covered.">    if (input == null) {</span>
<span class="fc" id="L1165">      return EMPTY_STRING;</span>
    }
<span class="fc" id="L1167">    String str = input.toString();</span>
<span class="fc" id="L1168">    int i = str.length() - 1;</span>
    LOOP:
<span class="fc bfc" id="L1170" title="All 2 branches covered.">    for (; i &gt;= 0; --i) {</span>
<span class="fc bfc" id="L1171" title="All 2 branches covered.">      for (int j = 0; j &lt; chars.length(); ++j) {</span>
<span class="fc bfc" id="L1172" title="All 2 branches covered.">        if (str.charAt(i) == chars.charAt(j)) {</span>
<span class="fc" id="L1173">          continue LOOP;</span>
        }
      }
<span class="fc" id="L1176">      break;</span>
    }
<span class="fc bfc" id="L1178" title="All 2 branches covered.">    return i == str.length() - 1 ? str : str.substring(0, i + 1);</span>
  }

  /**
   * Left and right-trims the specified string. The resulting string will neither
   * start nor end with any of the specified characters.
   *
   * @param input the {@code String} to trim
   * @param chars the character to trim off the {@code String} (must not be
   *     {@code null} or empty)
   * @return the trimmed {@code String}.
   */
  public static String trim(Object input, String chars) {
<span class="fc" id="L1191">    return rtrim(ltrim(input, chars), chars);</span>
  }

  /**
   * Substring method that facilitates substring retrieval relative to the end of a
   * string. If {@code from} is negative, it is taken relative to the end of the
   * string ({@code -1} being equivalent to {@code str.length()-1}).
   *
   * @param str the {@code String} to extract a substring from
   * @param from the start index within {@code string} (may be negative)
   * @return the substring
   */
  public static String substr(String str, int from) {
<span class="fc" id="L1204">    Check.notNull(str, STR);</span>
<span class="fc" id="L1205">    int sz = str.length();</span>
<span class="fc bfc" id="L1206" title="All 2 branches covered.">    if (from &lt; 0) {</span>
<span class="fc" id="L1207">      from = sz + from;</span>
    }
<span class="fc" id="L1209">    Check.that(from, FROM_INDEX).is(gte(), 0).is(lte(), sz);</span>
<span class="fc" id="L1210">    return str.substring(from);</span>
  }

  /**
   * Substring method that facilitates substring retrieval relative to the end of a
   * string as well as substring retrieval in the opposite direction. If {@code from}
   * is negative, it is taken relative to the end of the string ({@code -1} being
   * equivalent to {@code str.length()-1}). If {@code length} is negative, the
   * substring is taken in the opposite direction. The character at {@code from} will
   * then be the &lt;i&gt;last&lt;/i&gt; character of the substring.
   *
   * @param str the {@code String} to extract a substring from. &lt;i&gt;Must not be
   *     null.&lt;/i&gt;
   * @param from the start index within {@code string} (may be negative)
   * @param length the desired length of the substring
   * @return the substring
   * @see CollectionMethods#sublist(List, int, int)
   */
  public static String substr(String str, int from, int length) {
<span class="fc" id="L1229">    Check.notNull(str, STR);</span>
<span class="fc" id="L1230">    int sz = str.length();</span>
    int start;
<span class="fc bfc" id="L1232" title="All 2 branches covered.">    if (from &lt; 0) {</span>
<span class="fc" id="L1233">      start = from + sz;</span>
<span class="fc" id="L1234">      Check.that(start, FROM_INDEX).is(gte(), 0);</span>
    } else {
<span class="fc" id="L1236">      start = from;</span>
<span class="fc" id="L1237">      Check.that(start, FROM_INDEX).is(lte(), sz);</span>
    }
    int end;
<span class="fc bfc" id="L1240" title="All 2 branches covered.">    if (length &gt;= 0) {</span>
<span class="fc" id="L1241">      end = start + length;</span>
    } else {
<span class="fc" id="L1243">      end = start + 1;</span>
<span class="fc" id="L1244">      start = end + length;</span>
<span class="fc" id="L1245">      Check.that(start, FROM_INDEX).is(gte(), 0);</span>
    }
<span class="fc" id="L1247">    Check.that(end, TO_INDEX).is(lte(), sz);</span>
<span class="fc" id="L1248">    return str.substring(start, end);</span>
  }

  /**
   * Returns the index of the nth occurrence of the specified substring within
   * {@code input}. To find the first occurrence of the specified substring, specify
   * 1 for {@code occurrence}; to find the second occurrence, specify 2, etc. If
   * {@code input} is {@code null}, or if there is no nth occurrence of the specified
   * substring, the return value will be -1. You can specify a negative occurrence to
   * search backwards from the end of the string. Specify -1 for the last occurrence
   * of the specified substring; -2 for the last-but-one occurrence, etc.
   *
   * @param input the string to search
   * @param substr the substring to search for (must not be null or empty)
   * @param occurrence the occurrence number of the substring (1 means: get index
   *     of 1st occurrence; -1 means: get index of last occurrence)
   * @return the index of the nth occurrence of the specified substring
   */
  public static int indexOf(Object input, String substr, int occurrence) {
<span class="fc" id="L1267">    Check.that(substr, &quot;substr&quot;).isNot(empty());</span>
<span class="fc" id="L1268">    Check.that(occurrence, &quot;occurrence&quot;).is(ne(), 0);</span>
    String str;
<span class="fc bfc" id="L1270" title="All 4 branches covered.">    if (input == null || (str = input.toString()).length() &lt; substr.length()) {</span>
<span class="fc" id="L1271">      return -1;</span>
    }
<span class="fc bfc" id="L1273" title="All 2 branches covered.">    if (substr.length() == 1) {</span>
<span class="fc bfc" id="L1274" title="All 2 branches covered.">      return occurrence &gt; 0</span>
<span class="fc" id="L1275">          ? charPosIndexOf(str, substr.charAt(0), occurrence)</span>
<span class="fc" id="L1276">          : charNegIndexOf(str, substr.charAt(0), occurrence);</span>
    }
<span class="fc bfc" id="L1278" title="All 2 branches covered.">    return occurrence &gt; 0</span>
<span class="fc" id="L1279">        ? strPosIndexOf(str, substr, occurrence)</span>
<span class="fc" id="L1280">        : strNegIndexOf(str, substr, occurrence);</span>
  }

  private static int charPosIndexOf(String str, char c, int occurrence) {
<span class="fc bfc" id="L1284" title="All 2 branches covered.">    for (int i = 0; i &lt; str.length(); ++i) {</span>
<span class="fc bfc" id="L1285" title="All 4 branches covered.">      if (str.charAt(i) == c &amp;&amp; --occurrence == 0) {</span>
<span class="fc" id="L1286">        return i;</span>
      }
    }
<span class="fc" id="L1289">    return -1;</span>
  }

  private static int charNegIndexOf(String str, char c, int occurrence) {
<span class="fc bfc" id="L1293" title="All 2 branches covered.">    for (int i = str.length() - 1; i &gt;= 0; --i) {</span>
<span class="fc bfc" id="L1294" title="All 4 branches covered.">      if (str.charAt(i) == c &amp;&amp; ++occurrence == 0) {</span>
<span class="fc" id="L1295">        return i;</span>
      }
    }
<span class="fc" id="L1298">    return -1;</span>
  }

  private static int strPosIndexOf(String str, String substr, int occurrence) {
<span class="fc bfc" id="L1302" title="All 2 branches covered.">    for (int i = 0; i &lt;= str.length() - substr.length(); ++i) {</span>
<span class="fc bfc" id="L1303" title="All 4 branches covered.">      if (str.regionMatches(i, substr, 0, substr.length()) &amp;&amp; --occurrence == 0) {</span>
<span class="fc" id="L1304">        return i;</span>
      }
    }
<span class="fc" id="L1307">    return -1;</span>
  }

  private static int strNegIndexOf(String str, String substr, int occurrence) {
<span class="fc bfc" id="L1311" title="All 2 branches covered.">    for (int i = str.length() - substr.length(); i &gt;= 0; --i) {</span>
<span class="fc bfc" id="L1312" title="All 4 branches covered.">      if (str.regionMatches(i, substr, 0, substr.length()) &amp;&amp; ++occurrence == 0) {</span>
<span class="fc" id="L1313">        return i;</span>
      }
    }
<span class="fc" id="L1316">    return -1;</span>
  }

  /**
   * Returns the substring up to, but not including the nth occurrence of the
   * specified substring, or the entire string if there is no nth occurrence of the
   * substring. Returns an empty string if {@code input} is {@code null}. Specify 1
   * to find the first occurrence of the substring; 2 to find the second occurrence,
   * etc.  Specify -1 to find the first occurrence; -2 to find the last-but-one
   * occurrence, etc.
   *
   * @param input the string to search
   * @param substr the substring to search for
   * @param occurrence the occurrence number of the substring. Specify 1 for
   *     first occurrence; 2 for second occurrence, etc. Specify -1 for last
   *     occurrence, -2 for last-but-one occurrence, etc.
   * @return a substring up to (not including) the nth occurrence of the specified
   *     substring
   */
  public static String substringBefore(Object input, String substr, int occurrence) {
<span class="fc" id="L1336">    int idx = indexOf(input, substr, occurrence);</span>
<span class="fc bfc" id="L1337" title="All 2 branches covered.">    if (idx == -1) {</span>
<span class="fc bfc" id="L1338" title="All 2 branches covered.">      return input == null ? EMPTY_STRING : input.toString();</span>
    }
<span class="fc" id="L1340">    return input.toString().substring(0, idx);</span>
  }

  /**
   * Returns the substring up to, and including the nth occurrence of the specified
   * substring, or the entire string if there is no nth occurrence of the substring.
   * Returns an empty string if {@code input} is {@code null}. Specify 1 to find the
   * first occurrence of the substring; 2 to find the second occurrence, etc. Specify
   * -1 to find the first occurrence; -2 to find the last-but-one occurrence, etc.
   *
   * @param input the string to search
   * @param substr the substring to search for
   * @param occurrence the occurrence number of the substring. Specify 1 for
   *     first occurrence; 2 for second occurrence, etc. Specify -1 for last
   *     occurrence, -2 for last-but-one occurrence, etc.
   * @return a substring up to, and including the nth occurrence of the specified
   *     substring
   */
  public static String substringOnTo(Object input, String substr, int occurrence) {
<span class="fc" id="L1359">    int idx = indexOf(input, substr, occurrence);</span>
<span class="fc bfc" id="L1360" title="All 2 branches covered.">    if (idx == -1) {</span>
<span class="fc bfc" id="L1361" title="All 2 branches covered.">      return input == null ? EMPTY_STRING : input.toString();</span>
    }
<span class="fc bfc" id="L1363" title="All 2 branches covered.">    if (input.getClass() == String.class) {</span>
<span class="fc" id="L1364">      String s = input.toString();</span>
<span class="fc bfc" id="L1365" title="All 2 branches covered.">      return idx + substr.length() == s.length()</span>
<span class="fc" id="L1366">          ? new String(s)</span>
<span class="fc" id="L1367">          : s.substring(0, idx + substr.length());</span>
    }
<span class="fc" id="L1369">    return input.toString().substring(0, idx + substr.length());</span>
  }

  /**
   * Returns the substring from (and including) the nth occurrence of the specified
   * substring, or the entire string if there is no nth occurrence of the substring.
   * Returns an empty string if {@code input} is {@code null}. Specify 1 to find the
   * first occurrence of the substring; 2 to find the second occurrence, etc. Specify
   * -1 to find the first occurrence; -2 to find the last-but-one occurrence, etc.
   *
   * @param input the string to search
   * @param substr the substring to search for
   * @param occurrence the occurrence number of the substring. Specify 1 for
   *     first occurrence; 2 for second occurrence, etc. Specify -1 for last
   *     occurrence, -2 for last-but-one occurrence, etc.
   * @return a substring from (inclusive) the nth occurrence of the specified
   *     substring
   */
  public static String substrFrom(Object input, String substr, int occurrence) {
<span class="fc" id="L1388">    int idx = indexOf(input, substr, occurrence);</span>
<span class="fc bfc" id="L1389" title="All 2 branches covered.">    if (idx == -1) {</span>
<span class="fc bfc" id="L1390" title="All 2 branches covered.">      return input == null ? EMPTY_STRING : input.toString();</span>
    }
<span class="fc bfc" id="L1392" title="All 2 branches covered.">    if (input.getClass() == String.class) {</span>
<span class="fc" id="L1393">      String s = input.toString();</span>
<span class="fc bfc" id="L1394" title="All 2 branches covered.">      return idx == 0 ? new String(s) : s.substring(idx);</span>
    }
<span class="fc" id="L1396">    return input.toString().substring(idx);</span>
  }

  /**
   * Returns the substring after the nth occurrence of the specified substring, or
   * the entire string if there is no nth occurrence of the substring. Returns an
   * empty string if {@code input} is {@code null}. Specify 1 to find the first
   * occurrence of the substring; 2 to find the second occurrence, etc. Specify -1 to
   * find the first occurrence; -2 to find the last-but-one occurrence, etc.
   *
   * @param input the string to search
   * @param substr the substring to search for
   * @param occurrence the occurrence number of the substring. Specify 1 for
   *     first occurrence; 2 for second occurrence, etc. Specify -1 for last
   *     occurrence, -2 for last-but-one occurrence, etc.
   * @return a substring after (not including) the nth occurrence of the specified
   *     substring
   */
  public static String substrAfter(Object input, String substr, int occurrence) {
<span class="fc" id="L1415">    int idx = indexOf(input, substr, occurrence);</span>
<span class="fc bfc" id="L1416" title="All 2 branches covered.">    if (idx == -1) {</span>
<span class="fc bfc" id="L1417" title="All 2 branches covered.">      return input == null ? EMPTY_STRING : input.toString();</span>
    }
<span class="fc" id="L1419">    return input.toString().substring(idx + substr.length());</span>
  }

  /**
   * Returns the line number and column number of the character at the specified
   * index, given the system-defined line separator.
   *
   * @param str the string to search
   * @param index the string index to determine the line and column number of
   * @return a two-element array containing the line number and column number of the
   *     character at the specified index
   */
  public static int[] getLineAndColumn(String str, int index) {
<span class="nc" id="L1432">    return getLineAndColumn(str, index, System.lineSeparator());</span>
  }

  /**
   * Returns the line number and column number of the character at the specified
   * index, given the specified line separator.
   *
   * @param str the string to search
   * @param index the string index to determine the line and column number of
   * @param lineSep the line separator
   * @return a two-element array containing the line number and column number of the
   *     character at the specified index
   */
  public static int[] getLineAndColumn(String str, int index, String lineSep) {
<span class="fc" id="L1446">    Check.that(str, STR).is(notNull())</span>
<span class="fc" id="L1447">        .and(index).is(indexInclusiveOf(), str, indexOutOfBounds(index))</span>
<span class="fc" id="L1448">        .and(lineSep, &quot;lineSep&quot;).isNot(empty());</span>
<span class="fc bfc" id="L1449" title="All 2 branches covered.">    if (index == 0) {</span>
<span class="fc" id="L1450">      return new int[] {0, 0};</span>
    }
<span class="fc" id="L1452">    int line = 0, pos = 0, i = str.indexOf(lineSep);</span>
<span class="fc bfc" id="L1453" title="All 4 branches covered.">    while (i != -1 &amp;&amp; i &lt; index) {</span>
<span class="fc" id="L1454">      ++line;</span>
<span class="fc" id="L1455">      pos = i + lineSep.length();</span>
<span class="fc" id="L1456">      i = str.indexOf(lineSep, i + lineSep.length());</span>
    }
<span class="fc" id="L1458">    return new int[] {line, index - pos};</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>