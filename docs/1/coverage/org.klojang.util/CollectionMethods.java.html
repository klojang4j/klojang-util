<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CollectionMethods.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Klojang Check</a> &gt; <a href="index.source.html" class="el_package">org.klojang.util</a> &gt; <span class="el_source">CollectionMethods.java</span></div><h1>CollectionMethods.java</h1><pre class="source lang-java linenums">package org.klojang.util;

import org.klojang.check.Check;
import org.klojang.check.aux.DuplicateValueException;
import org.klojang.check.fallible.FallibleFunction;

import java.util.*;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Stream;

import static java.util.Map.Entry;
import static java.util.Map.entry;
import static java.util.stream.Collectors.*;
import static org.klojang.check.CommonChecks.*;
import static org.klojang.check.CommonExceptions.duplicateKey;
import static org.klojang.check.CommonProperties.*;
import static org.klojang.check.Tag.*;
import static org.klojang.util.ArrayMethods.*;

/**
 * Methods extending the Java Collection framework.
 */
public final class CollectionMethods {

  static final String SEPARATOR = &quot;separator&quot;;
  static final String CONVERTER = &quot;converter&quot;;
  static final String STRINGIFIER = &quot;stringifier&quot;;

<span class="nc" id="L32">  private CollectionMethods() {</span>
<span class="nc" id="L33">    throw new UnsupportedOperationException();</span>
  }

<span class="fc" id="L36">  private static final Map&lt;Class&lt;?&gt;, Function&lt;Object, List&lt;?&gt;&gt;&gt; listifiers = Map.of(</span>
<span class="fc" id="L37">      int[].class, o -&gt; ArrayMethods.asList((int[]) o),</span>
<span class="fc" id="L38">      double[].class, o -&gt; ArrayMethods.asList((double[]) o),</span>
<span class="fc" id="L39">      long[].class, o -&gt; ArrayMethods.asList((long[]) o),</span>
<span class="fc" id="L40">      byte[].class, o -&gt; ArrayMethods.asList((byte[]) o),</span>
<span class="fc" id="L41">      char[].class, o -&gt; ArrayMethods.asList((char[]) o),</span>
<span class="fc" id="L42">      float[].class, o -&gt; ArrayMethods.asList((float[]) o),</span>
<span class="fc" id="L43">      short[].class, o -&gt; ArrayMethods.asList((short[]) o),</span>
<span class="fc" id="L44">      boolean[].class, o -&gt; ArrayMethods.asList((boolean[]) o)</span>
  );

  /**
   * &lt;p&gt;Converts the specified value to a {@code List}.
   *
   * &lt;ul&gt;
   *   &lt;li&gt;if the value already is a {@code List}, it is returned as-is.
   *   &lt;li&gt;if the value is a {@code Collection}, it is
   *      converted to an {@link ArrayList} using the standard Collections Framework
   *      conversion mechanism &amp;#8212; by passing it to the constructor of
   *      {@code ArrayList}
   *   &lt;li&gt;if the value is an instance of {@code Object[]}, it is converted using
   *      {@link Arrays#asList(Object[]) Arrays.asList}
   *   &lt;li&gt;if the value is an array of a primitive type, it is converted using
   *      {@link ArrayMethods#asList(int[]) ArrayMethods.asList}
   *   &lt;li&gt;in any other case the value is converted using
   *      {@link Collections#singletonList(Object) Collections.singletonList}
   * &lt;/ul&gt;
   *
   * &lt;p&gt;In other words, this method takes the shortest route to turn the value into
   * a {@code List} and there is no guarantee about what type of {@code List}
   * you get.
   *
   * @param value the value to convert
   * @return the value converted to a {@code List}
   * @see ArrayMethods#box(int[])
   * @see ArrayMethods#asList(int[])
   */
  @SuppressWarnings({&quot;unchecked&quot;})
  public static List&lt;?&gt; listify(Object value) {
<span class="fc bfc" id="L75" title="All 2 branches covered.">    if (value != null) {</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">      if (value instanceof List&lt;?&gt; l) {</span>
<span class="fc" id="L77">        return l;</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">      } else if (value instanceof Collection&lt;?&gt; c) {</span>
<span class="fc" id="L79">        return new ArrayList&lt;&gt;(c);</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">      } else if (value instanceof Object[] o) {</span>
<span class="fc" id="L81">        return Arrays.asList(o);</span>
      }
<span class="fc" id="L83">      Function&lt;Object, List&lt;?&gt;&gt; fnc = listifiers.get(value.getClass());</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">      if (fnc != null) {</span>
<span class="fc" id="L85">        return fnc.apply(value);</span>
      }
    }
<span class="fc" id="L88">    return Collections.singletonList(value);</span>
  }

  /**
   * Returns a fixed-size, mutable {@code List} with all elements initialized to the
   * specified value. The initialization value must not be {@code null}.
   *
   * @param size The desired size of the {@code List}
   * @param initVal The initial value of the list elements (must not be
   *     {@code null})
   * @param &lt;E&gt; the type of the elements
   * @return a fixed-size, mutable, initialized {@code List}
   */
  @SuppressWarnings({&quot;unchecked&quot;})
  public static &lt;E&gt; List&lt;E&gt; initializeList(int size, E initVal) {
<span class="fc" id="L103">    Check.that(size, SIZE).is(gte(), 0);</span>
<span class="fc" id="L104">    Check.notNull(initVal, &quot;initialization value&quot;);</span>
<span class="fc" id="L105">    Object[] array = new Object[size];</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">    for (int i = 0; i &lt; size; ++i) {</span>
<span class="fc" id="L107">      array[i] = initVal;</span>
    }
<span class="fc" id="L109">    return (List&lt;E&gt;) Arrays.asList(array);</span>
  }

  /**
   * Returns a fixed-size, mutable {@code List} with all elements initialized to
   * values provided by a {@code Supplier}.
   *
   * @param size The desired size of the {@code List}
   * @param initValSupplier The supplier of the initial values
   * @param &lt;E&gt; the type of the elements
   * @return a fixed-size, mutable, initialized {@code List}
   */
  @SuppressWarnings({&quot;unchecked&quot;})
  public static &lt;E&gt; List&lt;E&gt; initializeList(int size, Supplier&lt;E&gt; initValSupplier) {
<span class="fc" id="L123">    Check.that(size, SIZE).is(gte(), 0);</span>
<span class="fc" id="L124">    Check.notNull(initValSupplier, &quot;supplier&quot;);</span>
<span class="fc" id="L125">    Object[] array = new Object[size];</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">    for (int i = 0; i &lt; size; ++i) {</span>
<span class="fc" id="L127">      array[i] = initValSupplier.get();</span>
    }
<span class="fc" id="L129">    return (List&lt;E&gt;) Arrays.asList(array);</span>
  }

  /**
   * Returns a new {@link ArrayList} initialized with the specified values. The
   * values are allowed to be {@code null}. The initial capacity will always be at
   * least the length of the {@code initVals} array, whatever the value of the
   * {@code capacity} argument.
   *
   * @param capacity The initial capacity of the list
   * @param initVals The values to add to the list
   * @param &lt;E&gt; the type of the list elements
   * @return a new {@link ArrayList} initialized with the specified values.
   */
  @SafeVarargs
  public static &lt;E&gt; List&lt;E&gt; newArrayList(int capacity, E... initVals) {
<span class="nc" id="L145">    Check.that(capacity, CAPACITY).is(gte(), 0);</span>
<span class="nc" id="L146">    Check.notNull(initVals, &quot;initVals&quot;);</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">    if (initVals.length == 0) {</span>
<span class="nc" id="L148">      return new ArrayList&lt;&gt;(Math.max(1, capacity));</span>
    }
<span class="nc" id="L150">    List&lt;E&gt; l = new ArrayList&lt;&gt;(Math.max(capacity, initVals.length));</span>
<span class="nc" id="L151">    l.addAll(Arrays.asList(initVals));</span>
<span class="nc" id="L152">    return l;</span>
  }

  /**
   * Returns a {@link HashMap} initialized with the specified key-value pairs. Both
   * keys and values are allowed to be {@code null}. Keys will be checked for
   * uniqueness.
   *
   * @param &lt;K&gt; the type of the keys
   * @param &lt;V&gt; the type of the values
   * @param size The expected number of map entries. No rehashing will take place
   *     until that number is reached. If you specify a number less than the number
   *     of key-value pairs (half the length of the varargs array), it will be taken
   *     as a multiplier. For example, 2 would mean that you expect the map to grow
   *     to about twice the specified number of key-value pairs.
   * @param keyClass The class of the keys
   * @param valueClass The class of the values
   * @param kvPairs An array alternating between keys and values
   * @return a {@code HashMap} initialized with the specified key-value pairs
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;K, V&gt; Map&lt;K, V&gt; newHashMap(
      int size, Class&lt;K&gt; keyClass, Class&lt;V&gt; valueClass, Object... kvPairs) {
<span class="fc" id="L175">    Check.that(size, CAPACITY).isNot(negative());</span>
<span class="fc" id="L176">    Check.notNull(kvPairs, &quot;kvPairs&quot;).has(length(), even());</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">    if (kvPairs.length == 0) {</span>
<span class="nc" id="L178">      return new HashMap&lt;&gt;(Math.max(1, size));</span>
    }
    int cap;
<span class="fc bfc" id="L181" title="All 2 branches covered.">    if (size &lt; kvPairs.length / 2) {</span>
<span class="fc" id="L182">      cap = Math.max(1, size) * kvPairs.length;</span>
    } else {
<span class="fc" id="L184">      cap = size;</span>
    }
<span class="fc" id="L186">    HashMap&lt;K, V&gt; map = new HashMap&lt;&gt;(1 + cap * 4 / 3);</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">    for (int i = 0; i &lt; kvPairs.length - 1; i += 2) {</span>
<span class="fc" id="L188">      K key = (K) kvPairs[i];</span>
<span class="fc" id="L189">      V val = (V) kvPairs[i + 1];</span>
<span class="fc" id="L190">      Check.that(key).isNot(keyIn(),</span>
          map,
          &quot;duplicate key at position ${0}: ${arg}&quot;,
<span class="fc" id="L193">          i);</span>
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">      if (key != null) {</span>
<span class="fc" id="L195">        Check.that(key, &quot;kvPairs[&quot; + i + &quot;]&quot;).is(instanceOf(), keyClass);</span>
      }
<span class="fc bfc" id="L197" title="All 2 branches covered.">      if (val != null) {</span>
<span class="fc" id="L198">        Check.that(val, &quot;kvPairs[&quot; + (i + 1) + &quot;]&quot;).is(instanceOf(), valueClass);</span>
      }
<span class="fc" id="L200">      map.put(key, val);</span>
    }
<span class="fc" id="L202">    return map;</span>
  }

  /**
   * Returns an {@link EnumMap} with all enum constants set to non-null values. The
   * number of values must exactly equal the number of enum constants, and they are
   * assigned according to ordinal number. This method throws an
   * {@link IllegalArgumentException} if the number of values is not exactly equal to
   * the number of constants in the enum class, or if any of the values is null.
   *
   * @param &lt;K&gt; the key type
   * @param &lt;V&gt; the value type
   * @param enumClass The enum class
   * @param values The values to associate with the enum constants
   * @return a fully-occupied {@code EnumMap} with no null-values
   * @throws IllegalArgumentException if {@code enumClass} or {@code Values} is
   *     null, or if any of the provided values is null, or is the number of values
   *     is not exactly equals to the number of enum constants
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;K extends Enum&lt;K&gt;, V&gt; EnumMap&lt;K, V&gt; saturatedEnumMap(
      Class&lt;K&gt; enumClass, V... values) throws IllegalArgumentException {
<span class="fc" id="L224">    K[] constants = Check.notNull(enumClass, &quot;enumClass&quot;).ok().getEnumConstants();</span>
<span class="fc" id="L225">    Check.notNull(values, VALUES).has(length(), eq(), constants.length);</span>
<span class="fc" id="L226">    EnumMap&lt;K, V&gt; map = new EnumMap&lt;&gt;(enumClass);</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">    for (int i = 0; i &lt; constants.length; ++i) {</span>
<span class="fc" id="L228">      Check.that(values[i]).is(notNull(),</span>
          &quot;Illegal null value for key ${0}&quot;,
          constants[i]);
<span class="fc" id="L231">      map.put(constants[i], values[i]);</span>
    }
<span class="fc" id="L233">    return map;</span>
  }

  /**
   * Returns a sublist of the provided list starting with element {@code from} and
   * containing at most {@code length} elements. The returned list is backed by the
   * original list, so changing its elements will affect the original list as well.
   * If {@code offset} is negative, it is taken relative to the end of the list. If
   * {@code length} is negative, the sublist is taken in the opposite direction
   * &amp;#8212; that is, the element at {@code offset} now becomes the &lt;i&gt;last&lt;/i&gt;
   * element of the sublist.
   *
   * @param list the {@code List} to extract a sublist from
   * @param offset the start index if the sublist (however, see above)
   * @param length the length of the sublist
   * @param &lt;T&gt; the type of the elements
   * @return a sublist of the provided list
   */
  public static &lt;T&gt; List&lt;T&gt; sublist(List&lt;T&gt; list, int offset, int length) {
<span class="fc" id="L252">    Check.notNull(list, LIST);</span>
<span class="fc" id="L253">    int sz = list.size();</span>
    int from;
<span class="fc bfc" id="L255" title="All 2 branches covered.">    if (offset &lt; 0) {</span>
<span class="fc" id="L256">      from = offset + sz;</span>
<span class="fc" id="L257">      Check.that(from, OFFSET).is(gte(), 0);</span>
    } else {
<span class="fc" id="L259">      from = offset;</span>
<span class="fc" id="L260">      Check.that(from, OFFSET).is(lte(), sz);</span>
    }
    int to;
<span class="fc bfc" id="L263" title="All 2 branches covered.">    if (length &gt;= 0) {</span>
<span class="fc" id="L264">      to = from + length;</span>
    } else {
<span class="fc" id="L266">      to = from + 1;</span>
<span class="fc" id="L267">      from = to + length;</span>
<span class="fc" id="L268">      Check.that(from, &quot;effective from-index&quot;).is(gte(), 0);</span>
    }
<span class="fc" id="L270">    Check.that(to, &quot;effective to-index&quot;).is(lte(), sz);</span>
<span class="fc" id="L271">    return list.subList(from, to);</span>
  }

  /**
   * Returns a new {@code Map} where keys and values of the input map have traded
   * places. The specified {@code Map} must not contain duplicate values. An
   * {@link IllegalArgumentException} is thrown if it does. The returned map is
   * tightly sized, but modifiable.
   *
   * @param &lt;K&gt; the type of the keys in the original map, and of the values in
   *     the returned map
   * @param &lt;V&gt; the type of the values in the original map, and of the keys in
   *     the returned map
   * @param map The source map
   * @return a new {@code Map} where keys and values are swapped
   */
  public static &lt;K, V&gt; Map&lt;V, K&gt; swap(Map&lt;K, V&gt; map) {
<span class="fc" id="L288">    return swap(map, () -&gt; new HashMap&lt;&gt;(1 + map.size() * 4 / 3));</span>
  }

  /**
   * Returns a new {@code Map} where keys and values of the input map have traded
   * places. The specified {@code Map} must not contain duplicate values. A
   * {@link DuplicateValueException} is thrown if it does. {@code null} keys and
   * values are allowed, however.
   *
   * @param &lt;K&gt; the type of the keys in the original map, and of the values in
   *     the returned map
   * @param &lt;V&gt; the type of the values in the original map, and of the keys in
   *     the returned map
   * @param map The source map
   * @param mapFactory A supplier of a {@code Map} instance
   * @return a new {@code Map} where keys and values are swapped
   * @throws DuplicateValueException if the map contains duplicate values
   */
  public static &lt;K, V&gt; Map&lt;V, K&gt; swap(Map&lt;K, V&gt; map,
      Supplier&lt;? extends Map&lt;V, K&gt;&gt; mapFactory) throws DuplicateValueException {
<span class="fc" id="L308">    Check.notNull(map, MAP);</span>
<span class="fc" id="L309">    Check.notNull(mapFactory, &quot;mapFactory&quot;);</span>
<span class="fc" id="L310">    Map&lt;V, K&gt; out = mapFactory.get();</span>
<span class="fc" id="L311">    map.forEach((k, v) -&gt; out.put(v, k));</span>
<span class="fc" id="L312">    return Check.that(out).has(mapSize(), eq(), map.size(), duplicateKey()).ok();</span>
  }

  /**
   * Returns an unmodifiable {@code Map} where keys and values of the input map have
   * traded places. The specified {@code Map} must not contain {@code null} keys,
   * {@code null} values or duplicate values. An {@link IllegalArgumentException} is
   * thrown if it does.
   *
   * @param &lt;K&gt; the type of the keys in the original map, and of the values in
   *     the returned map
   * @param &lt;V&gt; the type of the values in the original map, and of the keys in
   *     the returned map
   * @param map The source map
   * @return a new {@code Map} where keys and values are swapped
   */
  public static &lt;K, V&gt; Map&lt;V, K&gt; swapAndFreeze(Map&lt;K, V&gt; map) {
<span class="fc" id="L329">    Map&lt;V, K&gt; out = deepFreeze(map, e -&gt; entry(e.getValue(), e.getKey()));</span>
<span class="fc" id="L330">    return Check.that(out).has(mapSize(), eq(), map.size(), duplicateKey()).ok();</span>
  }

  /**
   * Returns an unmodifiable {@code Map} where the values of the input {@code Map}
   * have been converted using the specified {@code Function}. The specified
   * {@code Map} must not contain {@code null} keys, {@code null} values or duplicate
   * values. An {@link IllegalArgumentException} is thrown if it does.
   *
   * @param &lt;K&gt; the type of the keys of the input and output {@code Map}
   * @param &lt;V0&gt; the type of the values of the input {@code Map}
   * @param &lt;V1&gt; the type of the values of the output {@code Map}
   * @param src the input {@code Map}
   * @param valueConverter A {@code Function} that converts the values of the
   *     input {@code Map}
   * @return an unmodifiable {@code Map} where the values of the input {@code Map}
   *     have been converted using the specified {@code Function}
   */
  public static &lt;K, V0, V1&gt; Map&lt;K, V1&gt; freeze(
      Map&lt;K, V0&gt; src, Function&lt;? super V0, ? extends V1&gt; valueConverter) {
<span class="fc" id="L350">    Check.notNull(src, MAP);</span>
<span class="fc" id="L351">    Check.notNull(valueConverter, &quot;value converter&quot;);</span>
<span class="fc" id="L352">    return src.entrySet().stream()</span>
<span class="fc" id="L353">        .peek(checkEntry())</span>
<span class="fc" id="L354">        .map(toEntryConverter(valueConverter))</span>
<span class="fc" id="L355">        .collect(toUnmodifiableMap(key(), value()));</span>
  }

  /**
   * Returns an unmodifiable {@code Map} where the values of the input {@code Map}
   * have been converted using the specified {@code BiFunction}. This method passes
   * both the key and the value to the converter function so you can make the
   * conversion key-dependent, or so you can mention the key if the conversion
   * fails.
   *
   * @param &lt;K&gt; the type of the keys of the input and output {@code Map}
   * @param &lt;V0&gt; the type of the values of the input {@code Map}
   * @param &lt;V1&gt; the type of the values of the output {@code Map}
   * @param src the input {@code Map}
   * @param valueConverter A {@code Function} that converts the values of the
   *     input {@code Map}
   * @return an unmodifiable {@code Map} where the values of the input {@code Map}
   *     have been converted using the specified {@code Function}
   */
  public static &lt;K, V0, V1&gt; Map&lt;K, V1&gt; freeze(
      Map&lt;K, V0&gt; src,
      BiFunction&lt;? super K, ? super V0, ? extends V1&gt; valueConverter) {
<span class="fc" id="L377">    Check.notNull(src, MAP);</span>
<span class="fc" id="L378">    Check.notNull(valueConverter, &quot;value converter&quot;);</span>
<span class="fc" id="L379">    return src.entrySet().stream()</span>
<span class="fc" id="L380">        .peek(checkEntry())</span>
<span class="fc" id="L381">        .map(toEntryConverter(valueConverter))</span>
<span class="fc" id="L382">        .collect(toUnmodifiableMap(key(), value()));</span>
  }

  /**
   * Returns an unmodifiable {@code Map} where both keys and values of the input
   * {@code Map} have been converted using the specified {@code Function}. The output
   * map may be smaller than the input map if the conversion function does not
   * generate unique keys.
   *
   * @param src the input {@code Map}
   * @param entryConverter a {@code Function} that produces a new entry from the
   *     original entry
   * @param &lt;K0&gt; The type of the keys in the input map
   * @param &lt;V0&gt; the type of the values in the input map
   * @param &lt;K1&gt; the type of the keys in the output map
   * @param &lt;V1&gt; the type of the values in the output map
   * @return an unmodifiable {@code Map} where the values of the input {@code Map}
   *     have been converted using the specified {@code Function}
   */
  public static &lt;K0, V0, K1, V1&gt; Map&lt;K1, V1&gt; deepFreeze(
      Map&lt;K0, V0&gt; src, Function&lt;Entry&lt;K0, V0&gt;, Entry&lt;K1, V1&gt;&gt; entryConverter) {
<span class="fc" id="L403">    Check.notNull(src, MAP);</span>
<span class="fc" id="L404">    Check.notNull(entryConverter, &quot;entry converter&quot;);</span>
<span class="fc" id="L405">    Map&lt;K1, V1&gt; out = new HashMap&lt;&gt;(1 + src.size() * 4 / 3);</span>
<span class="fc" id="L406">    src.entrySet().stream()</span>
<span class="fc" id="L407">        .peek(checkEntry())</span>
<span class="fc" id="L408">        .map(entryConverter)</span>
<span class="fc" id="L409">        .forEach(e -&gt; out.put(e.getKey(), e.getValue()));</span>
<span class="fc" id="L410">    return Map.copyOf(out);</span>
  }

  private static &lt;K, V0, V1&gt; Function&lt;Entry&lt;K, V0&gt;, Entry&lt;K, V1&gt;&gt; toEntryConverter(
      BiFunction&lt;? super K, ? super V0, ? extends V1&gt; fnc) {
<span class="fc" id="L415">    return e -&gt; entry(e.getKey(), fnc.apply(e.getKey(), e.getValue()));</span>
  }

  private static &lt;K, V0, V1&gt; Function&lt;Entry&lt;K, V0&gt;, Entry&lt;K, V1&gt;&gt; toEntryConverter(
      Function&lt;? super V0, ? extends V1&gt; fnc) {
<span class="fc" id="L420">    return e -&gt; entry(e.getKey(), fnc.apply(e.getValue()));</span>
  }

  private static &lt;K, V&gt; Consumer&lt;Entry&lt;K, V&gt;&gt; checkEntry() {
<span class="fc" id="L424">    return e -&gt;</span>
<span class="fc" id="L425">        Check.that(e)</span>
<span class="fc" id="L426">            .has(key(), notNull(), &quot;Illegal null key for value ${0}&quot;, e.getValue())</span>
<span class="fc" id="L427">            .has(value(), notNull(), &quot;Illegal null value for key ${0}&quot;, e.getKey());</span>
  }

  /**
   * Returns an unmodifiable {@code List} containing the values that result from
   * applying the specified function to the source list's elements. The conversion
   * function is allowed to throw a checked exception.
   *
   * @param &lt;T&gt; the type of the elements in the source list
   * @param &lt;U&gt; the type of the elements in the returned list
   * @param &lt;E&gt; the type of exception thrown if the conversion fails
   * @param src the source list
   * @param converter the conversion function
   * @return an unmodifiable {@code List} containing the values that result from
   *     applying the specified function to the source list's elements
   * @throws E the exception potentially being thrown from the conversion
   *     function
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;T, U, E extends Throwable&gt; List&lt;U&gt; freeze(
      List&lt;? extends T&gt; src, FallibleFunction&lt;? super T, ? extends U, E&gt; converter)
      throws E {
<span class="fc" id="L449">    Check.notNull(src, LIST);</span>
<span class="fc" id="L450">    Check.notNull(converter, CONVERTER);</span>
<span class="fc" id="L451">    Object[] objs = new Object[src.size()];</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">    for (int i = 0; i &lt; src.size(); ++i) {</span>
<span class="fc" id="L453">      objs[i] = converter.apply(src.get(i));</span>
    }
<span class="fc" id="L455">    return (List&lt;U&gt;) List.of(objs);</span>
  }

  /**
   * Returns an unmodifiable {@code Set} containing the values that result from
   * applying the specified function to the source set's elements. The conversion
   * function is allowed to throw a checked exception.
   *
   * @param &lt;T&gt; the type of the elements in the source set
   * @param &lt;U&gt; the type of the elements in the returned set
   * @param &lt;E&gt; the type of exception thrown if the conversion fails
   * @param src the source set
   * @param converter the conversion function
   * @return an unmodifiable {@code Set} containing the values that result from
   *     applying the
   * @throws E the exception potentially being thrown from the conversion
   *     function
   */
  @SuppressWarnings({&quot;unchecked&quot;})
  public static &lt;T, U, E extends Throwable&gt; Set&lt;U&gt; freeze(
      Set&lt;? extends T&gt; src, FallibleFunction&lt;? super T, ? extends U, E&gt; converter)
      throws E {
<span class="fc" id="L477">    Check.notNull(src, SET);</span>
<span class="fc" id="L478">    Check.notNull(converter, CONVERTER);</span>
<span class="fc" id="L479">    Object[] objs = new Object[src.size()];</span>
<span class="fc" id="L480">    Iterator&lt;? extends T&gt; iterator = src.iterator();</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">    for (int i = 0; i &lt; src.size(); ++i) {</span>
<span class="fc" id="L482">      objs[i] = converter.apply(iterator.next());</span>
    }
<span class="fc" id="L484">    return (Set&lt;U&gt;) Set.of(objs);</span>
  }

  /**
   * Shortcut method. Returns an unmodifiable list using:
   *
   * &lt;blockquote&gt;
   *
   * &lt;pre&gt;{@code
   * src.stream().map(converter).collect(toUnmodifiableList());
   * }&lt;/pre&gt;
   *
   * &lt;/blockquote&gt;
   *
   * @param &lt;T&gt; the type of the elements in the source set
   * @param &lt;U&gt; the type of the elements in the returned list
   * @param src the source list
   * @param converter the conversion function
   * @return an unmodifiable {@code List} containing the values that result from
   *     applying the specified function to the source collection's elements
   */
  public static &lt;T, U&gt; List&lt;U&gt; collectionToList(
      Collection&lt;? extends T&gt; src, Function&lt;? super T, ? extends U&gt; converter) {
<span class="fc" id="L507">    Check.notNull(src, COLLECTION);</span>
<span class="fc" id="L508">    Check.notNull(converter, CONVERTER);</span>
<span class="fc" id="L509">    return src.stream().map(converter).collect(toUnmodifiableList());</span>
  }

  /**
   * Shortcut method. Returns an unmodifiable set using:
   *
   * &lt;blockquote&gt;
   *
   * &lt;pre&gt;{@code
   * src.stream().map(converter).collect(toUnmodifiableSet());
   * }&lt;/pre&gt;
   *
   * &lt;/blockquote&gt;
   *
   * @param &lt;T&gt; the type of the elements in the source set
   * @param &lt;U&gt; the type of the elements in the returned list
   * @param src the source list
   * @param converter the conversion function
   * @return an unmodifiable {@code Set} containing the values that result from
   *     applying the specified function to the source collection's elements
   */
  public static &lt;T, U&gt; Set&lt;U&gt; collectionToSet(
      Collection&lt;? extends T&gt; src, Function&lt;? super T, ? extends U&gt; converter) {
<span class="fc" id="L532">    Check.notNull(src, COLLECTION);</span>
<span class="fc" id="L533">    Check.notNull(converter, CONVERTER);</span>
<span class="fc" id="L534">    return src.stream().map(converter).collect(toUnmodifiableSet());</span>
  }

  /**
   * Shortcut method. Returns an unmodifiable map from the specified collection
   * using:
   *
   * &lt;blockquote&gt; &lt;pre&gt;{@code
   * src.stream().collect(toUnmodifiableMap(keyExtractor, Function.identity()))
   * }&lt;/pre&gt; &lt;/blockquote&gt;
   *
   * @param &lt;K&gt; the type of the keys
   * @param &lt;V&gt; the type of the values and the list elements
   * @param src the {@code List} to convert.
   * @param keyExtractor The key-extraction function
   * @return an unmodifiable {@code Map}
   */
  public static &lt;K, V&gt; Map&lt;K, V&gt; collectionToMap(
      Collection&lt;V&gt; src, Function&lt;? super V, ? extends K&gt; keyExtractor) {
<span class="fc" id="L553">    Check.notNull(src, COLLECTION);</span>
<span class="fc" id="L554">    Check.notNull(keyExtractor, &quot;key extractor&quot;);</span>
<span class="fc" id="L555">    return src.stream().collect(toUnmodifiableMap(keyExtractor,</span>
<span class="fc" id="L556">        Function.identity()));</span>
  }

  /**
   * PHP-style implode method, concatenating the collection elements using &quot;, &quot;
   * (comma-space) as separator.
   *
   * @param collection the collection to implode
   * @param &lt;T&gt; the type of the elements
   * @return a concatenation of the elements in the collection.
   * @see ArrayMethods#implode(Object[])
   */
  public static &lt;T&gt; String implode(Collection&lt;T&gt; collection) {
<span class="fc" id="L569">    return implode(collection, IMPLODE_SEPARATOR);</span>
  }

  /**
   * PHP-style implode method, concatenating the collection elements with the
   * specified separator.
   *
   * @param collection the collection to implode
   * @param separator the string used to separate the elements
   * @param &lt;T&gt; the type of the elements
   * @return a concatenation of the elements in the collection.
   * @see ArrayMethods#implode(Object[])
   * @see ArrayMethods#implode(Object[], String)
   */
  public static &lt;T&gt; String implode(Collection&lt;T&gt; collection, String separator) {
<span class="fc" id="L584">    Check.notNull(collection);</span>
<span class="fc" id="L585">    return implode(collection, Objects::toString, separator, 0, -1);</span>
  }

  /**
   * PHP-style implode method, concatenating at most {@code limit} collection
   * elements using &quot;, &quot; (comma-space) as separator.
   *
   * @param collection the collection to implode
   * @param limit The maximum number of elements to collect. Specify -1 for no
   *     maximum. Specifying a number greater than the length of the collection is
   *     OK. It will be clamped to the collection length.
   * @param &lt;T&gt; the type of the elements
   * @return a concatenation of the elements in the collection.
   * @see ArrayMethods#implode(Object[])
   * @see ArrayMethods#implode(Object[], int)
   */
  public static &lt;T&gt; String implode(Collection&lt;T&gt; collection, int limit) {
<span class="fc" id="L602">    return implode(collection, IMPLODE_SEPARATOR, limit);</span>
  }

  /**
   * PHP-style implode method, concatenating at most {@code limit} collection
   * elements using &quot;, &quot; (comma-space) as separator.
   *
   * @param collection the collection to implode
   * @param stringifier a {@code Function} that converts the collection elements
   *     to strings
   * @param &lt;T&gt; the type of the elements
   * @return a concatenation of the elements in the collection.
   * @see ArrayMethods#implode(Object[])
   * @see ArrayMethods#implode(Object[], Function)
   */
  public static &lt;T&gt; String implode(Collection&lt;T&gt; collection,
      Function&lt;T, String&gt; stringifier) {
<span class="fc" id="L619">    return implode(collection, stringifier, IMPLODE_SEPARATOR, 0, -1);</span>
  }

  /**
   * PHP-style implode method, concatenating at most {@code limit} collection
   * elements using the specified separator.
   *
   * @param collection the collection to implode
   * @param separator the string used to separate the elements
   * @param limit The maximum number of elements to collect. Specify -1 for no
   *     maximum. Specifying a number greater than the length of the collection is
   *     OK. It will be clamped to the collection length.
   * @param &lt;T&gt; the type of the elements
   * @return a concatenation of the elements in the collection.
   * @see ArrayMethods#implode(Object[])
   * @see ArrayMethods#implode(Object[], String, int)
   */
  public static &lt;T&gt; String implode(Collection&lt;T&gt; collection,
      String separator,
      int limit) {
<span class="fc" id="L639">    return implode(collection, Objects::toString, separator, 0, limit);</span>
  }

  /**
   * PHP-style implode method.
   *
   * @param collection the collection to implode
   * @param stringifier a {@code Function} that converts the collection elements
   *     to strings
   * @param separator the string used to separate the elements
   * @param from the index of the element to begin the concatenation with
   *     (inclusive)
   * @param to the index of the element to end the concatenation with
   *     (exclusive). The specified number will be clamped to
   *     {@code collection.size()} (i.e. it's OK to specify a number greater than
   *     {@code collection.size()}). You can specify -1 as a shorthand for
   *     {@code collection.size()}.
   * @param &lt;T&gt; the type of the elements
   * @return a concatenation of the elements in the collection.
   * @see ArrayMethods#implode(Object[])
   * @see ArrayMethods#implode(Object[], Function, String, int, int)
   */
  @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
  public static &lt;T&gt; String implode(
      Collection&lt;T&gt; collection,
      Function&lt;T, String&gt; stringifier,
      String separator,
      int from,
      int to) {
<span class="fc" id="L668">    int sz = Check.notNull(collection, COLLECTION).ok(Collection::size);</span>
<span class="fc" id="L669">    Check.notNull(stringifier, STRINGIFIER);</span>
<span class="fc" id="L670">    Check.notNull(separator, SEPARATOR);</span>
<span class="fc" id="L671">    Check.that(from, FROM_INDEX).is(gte(), 0).is(lte(), sz);</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">    int x = to == -1 ? sz : Math.min(to, sz);</span>
<span class="fc" id="L673">    Check.that(x, &quot;to&quot;).is(gte(), from);</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">    if (from == 0) {</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">      Stream&lt;T&gt; stream = x == sz</span>
<span class="fc" id="L676">          ? collection.stream()</span>
<span class="fc" id="L677">          : collection.stream().limit(x);</span>
<span class="fc" id="L678">      return stream.map(stringifier).collect(joining(separator));</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">    } else if (collection instanceof List) {</span>
<span class="fc" id="L680">      List&lt;T&gt; sublist = ((List&lt;T&gt;) collection).subList(from, x);</span>
<span class="fc" id="L681">      return sublist.stream().map(stringifier).collect(joining(separator));</span>
    }
<span class="fc" id="L683">    Stream stream = Arrays.stream(collection.toArray(), from, x);</span>
<span class="fc" id="L684">    return (String) stream.map(stringifier).collect(joining(separator));</span>
  }

<span class="fc" id="L687">  private static final Set&lt;Class&gt; NULL_REPELLERS =</span>
      // Actually, List.of(1) and List.of(1, 2) currently have the same type, but
      // better safe than sorry. They will anyhow be de-duplicated when entering
      // the HashSet
<span class="fc" id="L691">      Set.copyOf(new HashSet&lt;&gt;(</span>
<span class="fc" id="L692">          Arrays.asList(</span>
<span class="fc" id="L693">              Collections.emptyList().getClass(),</span>
<span class="fc" id="L694">              Collections.emptySet().getClass(),</span>
<span class="fc" id="L695">              List.of().getClass(),</span>
<span class="fc" id="L696">              List.of(1).getClass(),</span>
<span class="fc" id="L697">              List.of(1, 2).getClass(),</span>
<span class="fc" id="L698">              List.of(1, 2, 3).getClass(),</span>
<span class="fc" id="L699">              Set.of().getClass(),</span>
<span class="fc" id="L700">              Set.of(1).getClass(),</span>
<span class="fc" id="L701">              Set.of(1, 2).getClass(),</span>
<span class="fc" id="L702">              Set.of(1, 2, 3).getClass())));</span>

  /**
   * Returns {@code true} if the provided collection is a null-repellent collection
   * like those obtained via {@code List.of(...)} and {@code Set.of(...)}. Note that
   * if this method returns {@code false}, it does not mean that the collection is
   * &lt;i&gt;not&lt;/i&gt; null-repellent. The only sure thing is that if this method returns
   * {@code true}, the collection is guaranteed not to contain {@code null} values.
   *
   * @param c the collection to inspect
   * @return {@code true} if the provided collection is a null-repellent collection
   */
  public static boolean isNullRepellent(Collection&lt;?&gt; c) {
<span class="fc" id="L715">    return NULL_REPELLERS.contains(c.getClass());</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>