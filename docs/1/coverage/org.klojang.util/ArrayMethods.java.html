<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ArrayMethods.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Klojang Util</a> &gt; <a href="index.source.html" class="el_package">org.klojang.util</a> &gt; <span class="el_source">ArrayMethods.java</span></div><h1>ArrayMethods.java</h1><pre class="source lang-java linenums">package org.klojang.util;

import org.klojang.check.Check;
import org.klojang.check.aux.Result;

import java.util.*;
import java.util.function.*;
import java.util.stream.IntStream;

import static java.lang.System.arraycopy;
import static java.util.function.Function.identity;
import static java.util.stream.Collectors.joining;
import static org.klojang.check.CommonChecks.*;
import static org.klojang.check.Tag.*;
import static org.klojang.util.CollectionMethods.SEPARATOR;
import static org.klojang.util.CollectionMethods.STRINGIFIER;
import static org.klojang.util.InvokeMethods.getArrayElement;
import static org.klojang.util.InvokeMethods.newArray;
import static org.klojang.util.ObjectMethods.ifNull;

/**
 * Methods for working with arrays.
 */
public final class ArrayMethods {

<span class="nc" id="L26">  private ArrayMethods() {</span>
<span class="nc" id="L27">    throw new UnsupportedOperationException();</span>
  }

  /**
   * A zero-length Object array.
   */
<span class="fc" id="L33">  public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];</span>

  /**
   * A zero-length String array.
   */
<span class="fc" id="L38">  public static final String[] EMPTY_STRING_ARRAY = new String[0];</span>

  /**
   * A zero-length {@code int} array.
   */
<span class="fc" id="L43">  public static final int[] EMPTY_INT_ARRAY = new int[0];</span>

  /**
   * A zero-length {@code long} array.
   */
<span class="fc" id="L48">  public static final long[] EMPTY_LONG_ARRAY = new long[0];</span>

  /**
   * Default separator for {@code ArrayMethods.implode} and
   * {@code CollectionMethods.implode}.
   */
  static final String IMPLODE_SEPARATOR = &quot;, &quot;;

<span class="fc" id="L56">  private static final Long MAX_ARR_LEN = (long) Integer.MAX_VALUE;</span>

  /**
   * Appends an element to an array.
   *
   * @param array the array to append the object to
   * @param obj the object to append
   * @param &lt;T&gt; the type of the array elements
   * @return a new array containing the original array plus the extra element
   */
  public static &lt;T&gt; T[] append(T[] array, T obj) {
<span class="fc" id="L67">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L68">    T[] arr = fromTemplate(array, array.length + 1);</span>
<span class="fc" id="L69">    arraycopy(array, 0, arr, 0, array.length);</span>
<span class="fc" id="L70">    arr[array.length] = obj;</span>
<span class="fc" id="L71">    return arr;</span>
  }

  /**
   * Appends multiple elements to an array.
   *
   * @param array the array to append the objects to
   * @param obj0 the 1st object to append
   * @param obj1 the 2nd object to append
   * @param moreObjs more objects to append
   * @param &lt;T&gt; the type of the array elements
   * @return a new array containing the original array plus the extra elements
   */
  @SafeVarargs
  public static &lt;T&gt; T[] append(T[] array, T obj0, T obj1, T... moreObjs) {
<span class="fc" id="L86">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L87">    Check.notNull(moreObjs, VARARGS);</span>
<span class="fc" id="L88">    int sz = array.length + 2 + moreObjs.length;</span>
<span class="fc" id="L89">    T[] arr = fromTemplate(array, sz);</span>
<span class="fc" id="L90">    arraycopy(array, 0, arr, 0, array.length);</span>
<span class="fc" id="L91">    arr[array.length] = obj0;</span>
<span class="fc" id="L92">    arr[array.length + 1] = obj1;</span>
<span class="fc" id="L93">    arraycopy(moreObjs, 0, arr, array.length + 2, moreObjs.length);</span>
<span class="fc" id="L94">    return arr;</span>
  }

  /**
   * Concatenates two arrays.
   *
   * @param arr0 The 1st array to go into the new array
   * @param arr1 The 2nd array to go into the new array
   * @param &lt;T&gt; the type of the array elements
   * @return a new array containing all elements of the specified arrays
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;T&gt; T[] concat(T[] arr0, T[] arr1) {
<span class="nc" id="L107">    return (T[]) concat(arr0, arr1, new Object[0][0]);</span>
  }

  /**
   * Concatenates multiple arrays into a single array.
   *
   * @param arr0 The 1st array to go into the new array
   * @param arr1 The 2nd array to go into the new array
   * @param arr2 The 3rd array to go into the new array
   * @param moreArrays More arrays to concatenate
   * @param &lt;T&gt; the type of the array elements
   * @return a new array containing all elements of the specified arrays
   */
  @SafeVarargs
  public static &lt;T&gt; T[] concat(T[] arr0, T[] arr1, T[] arr2, T[]... moreArrays) {
<span class="fc" id="L122">    Check.notNull(arr0, &quot;arr0&quot;);</span>
<span class="fc" id="L123">    Check.notNull(arr1, &quot;arr1&quot;);</span>
<span class="fc" id="L124">    Check.notNull(arr2, &quot;arr2&quot;);</span>
<span class="fc" id="L125">    Check.notNull(moreArrays, &quot;moreArrays&quot;);</span>
<span class="fc" id="L126">    long x = Arrays.stream(moreArrays).flatMap(Arrays::stream).count();</span>
<span class="fc" id="L127">    x += arr0.length + arr1.length + arr2.length;</span>
<span class="fc" id="L128">    Check.that(x).is(LTE(), MAX_ARR_LEN, &quot;too many elements: ${arg}&quot;);</span>
<span class="fc" id="L129">    T[] all = fromTemplate(arr0, (int) x);</span>
<span class="fc" id="L130">    int i = 0;</span>
<span class="fc" id="L131">    arraycopy(arr0, 0, all, i, arr0.length);</span>
<span class="fc" id="L132">    i += arr0.length;</span>
<span class="fc" id="L133">    arraycopy(arr1, 0, all, i, arr1.length);</span>
<span class="fc" id="L134">    i += arr1.length;</span>
<span class="fc" id="L135">    arraycopy(arr2, 0, all, i, arr2.length);</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">    if (moreArrays.length != 0) {</span>
<span class="fc" id="L137">      i += arr2.length;</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">      for (int j = 0; j &lt; moreArrays.length; ++j) {</span>
<span class="fc" id="L139">        T[] arr = moreArrays[j];</span>
<span class="fc" id="L140">        Check.that(arr).is(notNull(), &quot;array {0} must not be null&quot;, j + 4);</span>
<span class="fc" id="L141">        arraycopy(arr, 0, all, i, arr.length);</span>
<span class="fc" id="L142">        i += arr.length;</span>
      }
    }
<span class="fc" id="L145">    return all;</span>
  }

  /**
   * Returns {@code true} if the specified array contains the specified value.
   *
   * @param value the value to search for
   * @param array the array to search
   * @return whether the array contains the value
   * @see #indexOf(int[], int)
   */
  public static boolean isElementOf(int value, int[] array) {
<span class="fc" id="L157">    return indexOf(array, value).isPresent();</span>
  }

  /**
   * Returns {@code true} if the specified array contains the specified value.
   *
   * @param value the value to search for
   * @param array the array to search
   * @param &lt;T&gt; the type of the array elements
   * @return whether the array contains the value
   * @see #indexOf(Object[], Object)
   */
  public static &lt;T&gt; boolean isElementOf(T value, T[] array) {
<span class="fc bfc" id="L170" title="All 2 branches covered.">    return indexOf(array, value) != -1;</span>
  }

  /**
   * Returns {@code true} if the specified array contains the specified reference.
   *
   * @param reference the reference to search for
   * @param references the array to search
   * @return whether the array contains the reference
   * @see #refIndexOf(Object[], Object)
   */
  public static boolean isOneOf(Object reference, Object... references) {
<span class="nc bnc" id="L182" title="All 2 branches missed.">    return refIndexOf(references, reference) != -1;</span>
  }

  /**
   * Returns an {@link OptionalInt} containing the array index of the first occurrence of
   * the specified value within the specified array. Returns an empty {@link OptionalInt}
   * if the array does not contain the value.
   *
   * @param array the array to search
   * @param value the value to search for
   * @return an {@link OptionalInt} containing the array index of the value
   */
  public static OptionalInt indexOf(int[] array, int value) {
<span class="fc" id="L195">    Check.notNull(array, ARRAY);</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">    for (int x = 0; x &lt; array.length; ++x) {</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">      if (array[x] == value) {</span>
<span class="fc" id="L198">        return OptionalInt.of(x);</span>
      }
    }
<span class="fc" id="L201">    return OptionalInt.empty();</span>
  }

  /**
   * Returns an {@link OptionalInt} containing the array index of the last occurrence of
   * the specified value within the specified array. Returns an empty {@link OptionalInt}
   * if the array does not contain the value.
   *
   * @param array the array to search
   * @param value the value to search for
   * @return an {@link OptionalInt} containing the array index of the value
   */
  public static OptionalInt lastIndexOf(int[] array, int value) {
<span class="fc" id="L214">    Check.notNull(array, ARRAY);</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">    for (int x = array.length - 1; x &gt;= 0; --x) {</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">      if (array[x] == value) {</span>
<span class="fc" id="L217">        return OptionalInt.of(x);</span>
      }
    }
<span class="fc" id="L220">    return OptionalInt.empty();</span>
  }

  /**
   * Returns the array index of the first occurrence of the specified value within the
   * specified array. Returns -1 if the array does not contain the value. Searching for
   * null is allowed.
   *
   * @param &lt;T&gt; the type of the elements within the array
   * @param array the array to search
   * @param value the value to search for (may be null)
   * @return the array index of the value
   */
  public static &lt;T&gt; int indexOf(T[] array, T value) {
<span class="fc" id="L234">    Check.notNull(array, ARRAY);</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">    if (value == null) {</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">      for (int x = 0; x &lt; array.length; ++x) {</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">        if (array[x] == null) {</span>
<span class="fc" id="L238">          return x;</span>
        }
      }
    } else {
<span class="fc bfc" id="L242" title="All 2 branches covered.">      for (int x = 0; x &lt; array.length; ++x) {</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">        if (value.equals(array[x])) {</span>
<span class="fc" id="L244">          return x;</span>
        }
      }
    }
<span class="fc" id="L248">    return -1;</span>
  }

  /**
   * Returns the array index of the last occurrence of the specified value within the
   * specified array. Returns -1 if the array does not contain the value. Searching for
   * null is allowed.
   *
   * @param &lt;T&gt; the type of the elements within the array
   * @param array the array to search
   * @param value the value to search for (may be null)
   * @return the array index of the value
   */
  public static &lt;T&gt; int lastIndexOf(T[] array, T value) {
<span class="fc" id="L262">    Check.notNull(array, ARRAY);</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">    if (value == null) {</span>
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">      for (int x = array.length - 1; x &gt;= 0; --x) {</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">        if (array[x] == null) {</span>
<span class="fc" id="L266">          return x;</span>
        }
      }
    } else {
<span class="fc bfc" id="L270" title="All 2 branches covered.">      for (int x = array.length - 1; x &gt;= 0; --x) {</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">        if (value.equals(array[x])) {</span>
<span class="fc" id="L272">          return x;</span>
        }
      }
    }
<span class="fc" id="L276">    return -1;</span>
  }

  /**
   * Returns the array index of the first occurrence of the specified object, using
   * reference comparisons to identify the object. Returns -1 if the array does not
   * contain the specified reference. Searching for null is
   * &lt;i&gt;not&lt;/i&gt; allowed.
   *
   * @param array the array to search
   * @param reference The reference to search for (must not be null)
   * @return the array index of the reference
   */
  public static int refIndexOf(Object[] array, Object reference) {
<span class="fc" id="L290">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L291">    Check.notNull(reference, &quot;reference&quot;);</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">    for (int i = 0; i &lt; array.length; ++i) {</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">      if (array[i] == reference) {</span>
<span class="fc" id="L294">        return i;</span>
      }
    }
<span class="fc" id="L297">    return -1;</span>
  }

  /**
   * Returns the array index of the last occurrence of the specified object, using
   * reference comparisons to identify the object. Returns -1 if the array does not
   * contain the specified reference. Searching for null is &lt;i&gt;not&lt;/i&gt; allowed.
   *
   * @param array the array to search
   * @param reference The reference to search for (must not be null)
   * @return the array index of the reference
   */
  public static int refLastIndexOf(Object[] array, Object reference) {
<span class="fc" id="L310">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L311">    Check.notNull(reference, &quot;reference&quot;);</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">    for (int i = array.length - 1; i &gt;= 0; --i) {</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">      if (array[i] == reference) {</span>
<span class="fc" id="L314">        return i;</span>
      }
    }
<span class="nc" id="L317">    return -1;</span>
  }

  /**
   * Returns the first array element that passes the specified test, or
   * {@link Result#notAvailable()} if no element passed the test.
   *
   * @param array the array
   * @param test the test
   * @param &lt;T&gt; the type of the array elements
   * @return the first array element that passes the specified test, or
   * {@link Result#notAvailable()} if no element passed the test.
   */
  public static &lt;T&gt; Result&lt;T&gt; find(T[] array, Predicate&lt;T&gt; test) {
<span class="fc" id="L331">    return find(array, test, identity());</span>
  }

  /**
   * Returns a {@link Result} containing a property of the first array element that passes
   * the specified test, or {@link Result#notAvailable()} if no element passed the test.
   *
   * &lt;blockquote&gt;&lt;pre&gt;{@code
   * Person[] persons = getPersons();
   * find(persons, p -&gt; p.age() &lt; 15, Person::firstName).ifAvailable(
   *    name -&gt; System.out.printf(&quot;And the winner is ..... %s!!!%n, name);
   * );
   * }&lt;/pre&gt;&lt;/blockquote&gt;
   *
   * @param array the array
   * @param test the test
   * @param property a function that extracts some value from thr array element
   * @param &lt;T&gt; the type of the array elements
   * @param &lt;R&gt; the type of the value extracted from the array element
   * @return the {@code Result} containing the value extracted from the first array
   * element that passed the specified test, or {@code null} if no element passed the
   * test
   */
  public static &lt;T, R&gt; Result&lt;R&gt; find(
        T[] array,
        Predicate&lt;T&gt; test,
        Function&lt;T, R&gt; property) {
<span class="fc" id="L358">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L359">    Check.notNull(test, TEST);</span>
<span class="fc" id="L360">    Check.notNull(property, PROPERTY);</span>
<span class="fc" id="L361">    return Arrays.stream(array)</span>
<span class="fc" id="L362">          .filter(test)</span>
<span class="fc" id="L363">          .map(property)</span>
<span class="fc" id="L364">          .map(Result::of)</span>
<span class="fc" id="L365">          .findFirst()</span>
<span class="fc" id="L366">          .orElse(Result.notAvailable());</span>
  }

  /**
   * Returns the first array element that passes the specified test, or an empty
   * {@code OptionalInt} if no element passed the test.
   *
   * @param array the array
   * @param test the test
   * @return the first array element that passes the specified test, or an empty
   * {@code OptionalInt} if no element passed the test
   */
  public static OptionalInt find(int[] array, IntPredicate test) {
<span class="fc" id="L379">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L380">    Check.notNull(test, TEST);</span>
<span class="fc" id="L381">    return Arrays.stream(array)</span>
<span class="fc" id="L382">          .filter(test)</span>
<span class="fc" id="L383">          .mapToObj(OptionalInt::of)</span>
<span class="fc" id="L384">          .findFirst()</span>
<span class="fc" id="L385">          .orElse(OptionalInt.empty());</span>
  }

  /**
   * Reverses the order of the elements in the specified array.
   *
   * @param array the array
   * @param &lt;T&gt; the type of the array elements
   * @return the input array
   */
  public static &lt;T&gt; T[] reverse(T[] array) {
<span class="fc" id="L396">    return doReverse(array, 0, array.length);</span>
  }

  /**
   * Reverses the order of the elements in the specified array segment.
   *
   * @param array the array
   * @param from the start index (inclusive) of the array segment
   * @param to the end index (exclusive) of the array segment
   * @param &lt;T&gt; the type of the array elements
   * @return the input array
   */
  public static &lt;T&gt; T[] reverse(T[] array, int from, int to) {
<span class="fc" id="L409">    Check.fromTo(array, from, to);</span>
<span class="fc" id="L410">    return doReverse(array, from, to);</span>
  }

  private static &lt;T&gt; T[] doReverse(T[] array, int from, int to) {
<span class="fc bfc" id="L414" title="All 2 branches covered.">    for (int i = 0, j = to - 1; i &lt; (to - from) / 2; ++i, --j) {</span>
<span class="fc" id="L415">      T tmp = array[from + i];</span>
<span class="fc" id="L416">      array[from + i] = array[j];</span>
<span class="fc" id="L417">      array[j] = tmp;</span>
    }
<span class="fc" id="L419">    return array;</span>
  }

  /**
   * Reverses the order of the elements in the specified array.
   *
   * @param array the array
   * @return the input array
   */
  public static int[] reverse(int[] array) {
<span class="fc" id="L429">    return doReverse(array, 0, array.length);</span>
  }

  /**
   * Reverses the order of the elements in the specified array segment
   *
   * @param array the array
   * @param from the start index (inclusive) of the array segment
   * @param to the end index (exclusive) of the array segment
   * @return the input array
   */
  public static int[] reverse(int[] array, int from, int to) {
<span class="fc" id="L441">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L442">    Check.fromTo(array.length, from, to);</span>
<span class="fc" id="L443">    return doReverse(array, from, to);</span>
  }

  private static int[] doReverse(int[] array, int from, int to) {
<span class="fc bfc" id="L447" title="All 2 branches covered.">    for (int i = 0, j = to - 1; i &lt; (to - from) / 2; ++i, --j) {</span>
<span class="fc" id="L448">      int tmp = array[from + i];</span>
<span class="fc" id="L449">      array[from + i] = array[j];</span>
<span class="fc" id="L450">      array[j] = tmp;</span>
    }
<span class="fc" id="L452">    return array;</span>
  }

<span class="fc" id="L455">  private static final Map&lt;Class&lt;?&gt;, ToIntFunction&lt;Object&gt;&gt; hashCoders =</span>
<span class="fc" id="L456">        Map.of(</span>
<span class="fc" id="L457">              int[].class, obj -&gt; Arrays.hashCode((int[]) obj),</span>
<span class="nc" id="L458">              long[].class, obj -&gt; Arrays.hashCode((long[]) obj),</span>
<span class="nc" id="L459">              double[].class, obj -&gt; Arrays.hashCode((double[]) obj),</span>
<span class="nc" id="L460">              float[].class, obj -&gt; Arrays.hashCode((float[]) obj),</span>
<span class="nc" id="L461">              char[].class, obj -&gt; Arrays.hashCode((char[]) obj),</span>
<span class="nc" id="L462">              short[].class, obj -&gt; Arrays.hashCode((short[]) obj),</span>
<span class="nc" id="L463">              byte[].class, obj -&gt; Arrays.hashCode((byte[]) obj));</span>

  /**
   * Returns the hash code of an array. Allows you to retrieve the hash code of an array
   * object even if you don't know its exact type. An {@link IllegalArgumentException} is
   * thrown if the argument is not an array.
   *
   * @param array the array
   * @return Its hash code
   */
  public static int hashCode(Object array) {
<span class="fc" id="L474">    Check.notNull(array).is(array());</span>
<span class="pc bpc" id="L475" title="1 of 2 branches missed.">    if (array instanceof Object[] objs) {</span>
<span class="nc" id="L476">      return Arrays.hashCode(objs);</span>
    }
<span class="fc" id="L478">    return hashCoders.get(array.getClass()).applyAsInt(array);</span>
  }

  /**
   * Returns the deep hash code of an array. Allow you to retrieve the deep hash code of
   * an array object even if you don't know its exact type. An
   * {@link IllegalArgumentException} is thrown if the argument is not an array.
   *
   * @param array the array
   * @return Its deep hash code
   */
  public static int deepHashCode(Object array) {
<span class="nc" id="L490">    Check.notNull(array).is(array());</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">    if (array instanceof Object[] objs) {</span>
<span class="nc" id="L492">      return Arrays.deepHashCode(objs);</span>
    }
<span class="nc" id="L494">    return hashCoders.get(array.getClass()).applyAsInt(array);</span>
  }

  /**
   * PHP-style implode method, concatenating the array elements using &quot;, &quot; (comma+space)
   * as separator. Optimized for {@code int[]} arrays.
   *
   * @param array the array to implode
   * @return a concatenation of the elements in the array.
   */
  public static String implodeInts(int[] array) {
<span class="fc" id="L505">    return implodeInts(array, IMPLODE_SEPARATOR);</span>
  }

  /**
   * PHP-style implode method, concatenating the array elements using the specified
   * separator. Optimized for {@code int[]} arrays.
   *
   * @param array the array to implode
   * @param separator the string used to separate the elements
   * @return a concatenation of the elements in the array.
   */
  public static String implodeInts(int[] array, String separator) {
<span class="fc" id="L517">    return implodeInts(array, separator, -1);</span>
  }

  /**
   * PHP-style implode method, concatenating at most {@code limit} array elements using &quot;,
   * &quot; (comma+space) as separator.
   *
   * @param array the array to implode
   * @param limit The maximum number of elements to collect. The specified number will be
   * clamped to {@code array.length} (i.e. it's OK to specify a number greater than
   * {@code array.length}). You can specify -1 as a shorthand for {@code array.length}.
   * @return a concatenation of the elements in the array.
   */
  public static String implodeInts(int[] array, int limit) {
<span class="fc" id="L531">    return implodeInts(array, IMPLODE_SEPARATOR, limit);</span>
  }

  /**
   * PHP-style implode method, concatenating at most {@code limit} array elements using &quot;,
   * &quot; (comma+space) as separator.
   *
   * @param array the array to implode
   * @param stringifier A {@code Function} that converts the array elements to strings
   * @return a concatenation of the elements in the array.
   */
  public static String implodeInts(int[] array, IntFunction&lt;String&gt; stringifier) {
<span class="fc" id="L543">    return implodeInts(array, stringifier, IMPLODE_SEPARATOR, 0, -1);</span>
  }

  /**
   * PHP-style implode method, concatenating at most {@code limit} array elements using
   * the specified separator.
   *
   * @param array the array to implode
   * @param separator the string used to separate the elements
   * @param limit The maximum number of elements to collect. The specified number will be
   * clamped to {@code array.length} (i.e. it's OK to specify a number greater than
   * {@code array.length}). You can specify -1 as a shorthand for {@code array.length}.
   * @return a concatenation of the elements in the array.
   */
  public static String implodeInts(int[] array, String separator, int limit) {
<span class="fc" id="L558">    return implodeInts(array, String::valueOf, separator, 0, limit);</span>
  }

  /**
   * PHP-style implode method, optimized for {@code int[]} arrays.
   *
   * @param array the array to implode
   * @param stringifier A {@code Function} that converts the array elements to strings
   * @param separator the string used to separate the elements
   * @param from The index of the element to begin the concatenation with (inclusive)
   * @param to The index of the element to end the concatenation with (exclusive). The
   * specified number will be clamped to {@code array.length} (i.e. it's OK to specify a
   * number greater than {@code array.length}). You can specify -1 as a shorthand for
   * {@code array.length}.
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, Function, String, int, int)
   */
  public static String implodeInts(
        int[] array,
        IntFunction&lt;String&gt; stringifier,
        String separator,
        int from,
        int to) {
<span class="fc" id="L581">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L582">    Check.notNull(separator, SEPARATOR);</span>
<span class="fc" id="L583">    Check.that(from, FROM_INDEX).is(gte(), 0).is(lte(), array.length);</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">    int x = to == -1 ? array.length : Math.min(to, array.length);</span>
<span class="fc" id="L585">    Check.that(x, TO_INDEX).is(gte(), from);</span>
<span class="fc" id="L586">    return Arrays.stream(array, from, x)</span>
<span class="fc" id="L587">          .mapToObj(stringifier)</span>
<span class="fc" id="L588">          .collect(joining(separator));</span>
  }

  /**
   * PHP-style implode method, concatenating the array elements using &quot;, &quot; (comma+space)
   * as separator. This method is primarily meant to implode primitive arrays, but you
   * &lt;i&gt;can&lt;/i&gt; use it to implode any type of array. An {@link IllegalArgumentException}
   * is thrown if {@code array} is not an array.
   *
   * @param array the array to implode
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, String)
   */
  public static String implodeAny(Object array) {
<span class="fc" id="L602">    return implodeAny(array, Objects::toString, IMPLODE_SEPARATOR, 0, -1);</span>
  }

  /**
   * PHP-style implode method, concatenating the array elements using the specified
   * separator. This method is primarily meant to implode primitive arrays, but you
   * &lt;i&gt;can&lt;/i&gt; use it to implode any type of array. An {@link
   * IllegalArgumentException} is thrown if {@code array} is not an array.
   *
   * @param array the array to implode
   * @param separator the string used to separate the elements
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, String)
   */
  public static String implodeAny(Object array, String separator) {
<span class="fc" id="L617">    return implodeAny(array, separator, -1);</span>
  }

  /**
   * PHP-style implode method, concatenating the array elements using &quot;, &quot; (comma+space)
   * as separator. This method is primarily meant to implode primitive arrays, but you
   * &lt;i&gt;can&lt;/i&gt; use it to implode any type of array. An {@link IllegalArgumentException}
   * is thrown if {@code array} is not an array.
   *
   * @param array the array to implode
   * @param stringifier A {@code Function} that converts the array elements to strings
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, String)
   */
  public static String implodeAny(
        Object array,
        Function&lt;Object, String&gt; stringifier) {
<span class="fc" id="L634">    return implodeAny(array, stringifier, IMPLODE_SEPARATOR, 0, -1);</span>
  }


  /**
   * PHP-style implode method, concatenating the array elements using &quot;, &quot; (comma+space)
   * as separator. This method is primarily meant to implode primitive arrays, but you
   * &lt;i&gt;can&lt;/i&gt; use it to implode any type of array. An {@link IllegalArgumentException}
   * is thrown if {@code array} is not an array.
   *
   * @param array the array to implode
   * @param stringifier A {@code Function} that converts the array elements to strings
   * @param separator the string used to separate the elements
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, String)
   */
  public static String implodeAny(
        Object array,
        Function&lt;Object, String&gt; stringifier,
        String separator) {
<span class="nc" id="L654">    return implodeAny(array, stringifier, separator, 0, -1);</span>
  }

  /**
   * PHP-style implode method, concatenating at most {@code limit} array elements using &quot;,
   * &quot; (comma+space) as separator. This method is primarily meant to implode primitive
   * arrays, but you &lt;i&gt;can&lt;/i&gt; use it to implode any type of array. An
   * {@link IllegalArgumentException} is thrown if {@code array} is not an array.
   *
   * @param array the array to implode
   * @param limit The maximum number of elements to collect. The specified number will be
   * clamped to {@code array.length} (i.e. it's OK to specify a number greater than
   * {@code array.length}). You can specify -1 as a shorthand for {@code array.length}.
   * @return a concatenation of the elements in the array.
   */
  public static String implodeAny(Object array, int limit) {
<span class="fc" id="L670">    return implodeAny(array, IMPLODE_SEPARATOR, limit);</span>
  }

  /**
   * PHP-style implode method, concatenating at most {@code limit} array elements using
   * the specified separator. This method is primarily meant to implode primitive arrays,
   * but you &lt;i&gt;can&lt;/i&gt; use it to implode any type of array. An
   * {@link IllegalArgumentException} is thrown if {@code array} is not an array.
   *
   * @param array the array to implode
   * @param separator the string used to separate the elements
   * @param limit The maximum number of elements to collect. The specified number will be
   * clamped to {@code array.length} (i.e. it's OK to specify a number greater than
   * {@code array.length}). You can specify -1 as a shorthand for {@code array.length}.
   * @return a concatenation of the elements in the array.
   */
  public static String implodeAny(Object array, String separator, int limit) {
<span class="fc" id="L687">    return implodeAny(array, Objects::toString, separator, 0, limit);</span>
  }

  /**
   * PHP-style implode method. This method is primarily meant to implode primitive arrays,
   * but you &lt;i&gt;can&lt;/i&gt; use it to implode any type of array. An
   * {@link IllegalArgumentException} is thrown if {@code array} is not an array.
   *
   * @param array the array to implode
   * @param stringifier A {@code Function} that converts the array elements to strings
   * @param separator the string used to separate the elements
   * @param from The index of the element to begin the concatenation with (inclusive)
   * @param to The index of the element to end the concatenation with (exclusive). The
   * specified number will be clamped to {@code array.length} (i.e. it's OK to specify a
   * number greater than {@code array.length}). You can specify -1 as a shorthand for
   * {@code array.length}.
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, Function, String, int, int)
   */
  public static String implodeAny(
        Object array,
        Function&lt;Object, String&gt; stringifier,
        String separator,
        int from,
        int to) {
<span class="fc" id="L712">    int len = Check.notNull(array, ARRAY)</span>
<span class="fc" id="L713">          .is(array())</span>
<span class="fc" id="L714">          .ok(InvokeMethods::getArrayLength);</span>
<span class="fc" id="L715">    Check.notNull(stringifier, STRINGIFIER);</span>
<span class="fc" id="L716">    Check.notNull(separator, SEPARATOR);</span>
<span class="fc" id="L717">    Check.that(from, FROM_INDEX).is(gte(), 0).is(lte(), len);</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">    int x = to == -1 ? len : Math.min(to, len);</span>
<span class="fc" id="L719">    Check.that(x, TO_INDEX).is(gte(), from);</span>
<span class="fc" id="L720">    return IntStream.range(from, x)</span>
<span class="fc" id="L721">          .mapToObj(i -&gt; getArrayElement(array, i))</span>
<span class="fc" id="L722">          .map(stringifier)</span>
<span class="fc" id="L723">          .collect(joining(separator));</span>
  }

  /**
   * PHP-style implode method, concatenating the array elements using &quot;, &quot; (comma+space)
   * as separator.
   *
   * @param array the collection to implode
   * @param &lt;T&gt; the type of the array elements
   * @return a concatenation of the elements in the collection.
   * @see CollectionMethods#implode(Collection)
   */
  public static &lt;T&gt; String implode(T[] array) {
<span class="fc" id="L736">    return implode(array, IMPLODE_SEPARATOR);</span>
  }

  /**
   * PHP-style implode method, concatenating the array elements using the specified
   * separator.
   *
   * @param array the array to implode
   * @param separator the string used to separate the elements
   * @param &lt;T&gt; the type of the array elements
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, String)
   */
  public static &lt;T&gt; String implode(T[] array, String separator) {
<span class="fc" id="L750">    Check.notNull(array);</span>
<span class="fc" id="L751">    return implode(array, Objects::toString, separator, 0, -1);</span>
  }

  /**
   * PHP-style implode method, concatenating at most {@code limit} array elements using &quot;,
   * &quot; (comma+space) as separator.
   *
   * @param array the array to implode
   * @param limit The maximum number of elements to collect. The specified number will be
   * clamped to {@code array.length} (i.e. it's OK to specify a number greater than
   * {@code array.length}). You can specify -1 as a shorthand for {@code array.length}.
   * @param &lt;T&gt; the type of the array elements
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, int)
   */
  public static &lt;T&gt; String implode(T[] array, int limit) {
<span class="fc" id="L767">    return implode(array, IMPLODE_SEPARATOR, limit);</span>
  }

  /**
   * PHP-style implode method, concatenating at most {@code limit} array elements using &quot;,
   * &quot; (comma+space) as separator.
   *
   * @param array the array to implode
   * @param stringifier A {@code Function} that converts the array elements to strings
   * @param &lt;T&gt; the type of the array elements
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, int)
   */
  public static &lt;T&gt; String implode(T[] array, Function&lt;T, String&gt; stringifier) {
<span class="fc" id="L781">    return implode(array, stringifier, IMPLODE_SEPARATOR, 0, -1);</span>
  }

  /**
   * PHP-style implode method, concatenating at most {@code limit} array elements using &quot;,
   * &quot; (comma+space) as separator.
   *
   * @param array the array to implode
   * @param stringifier A {@code Function} that converts the array elements to strings
   * @param separator the string used to separate the elements
   * @param &lt;T&gt; the type of the array elements
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, int)
   */
  public static &lt;T&gt; String implode(
        T[] array,
        Function&lt;T, String&gt; stringifier,
        String separator) {
<span class="fc" id="L799">    return implode(array, stringifier, separator, 0, -1);</span>
  }

  /**
   * PHP-style implode method, concatenating at most {@code limit} array elements using
   * the specified separator.
   *
   * @param array the array to implode
   * @param separator the string used to separate the elements
   * @param limit The maximum number of elements to collect. The specified number will be
   * clamped to {@code array.length} (i.e. it's OK to specify a number greater than
   * {@code array.length}). You can specify -1 as a shorthand for {@code array.length}.
   * @param &lt;T&gt; the type of the array elements
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, String, int)
   */
  public static &lt;T&gt; String implode(T[] array, String separator, int limit) {
<span class="fc" id="L816">    return implode(array, Objects::toString, separator, 0, limit);</span>
  }

  /**
   * PHP-style implode method.
   *
   * @param array the array to implode
   * @param stringifier A {@code Function} that converts the array elements to strings
   * @param separator the string used to separate the elements
   * @param from The index of the element to begin the concatenation with (inclusive)
   * @param to The index of the element to end the concatenation with (exclusive). The
   * specified number will be clamped to {@code array.length} (i.e. it's OK to specify a
   * number greater than {@code array.length}). You can specify -1 as a shorthand for
   * {@code array.length}.
   * @param &lt;T&gt; the type of the array elements
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, Function, String, int, int)
   */
  public static &lt;T&gt; String implode(
        T[] array,
        Function&lt;T, String&gt; stringifier,
        String separator,
        int from,
        int to) {
<span class="fc" id="L840">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L841">    Check.notNull(stringifier, STRINGIFIER);</span>
<span class="fc" id="L842">    Check.notNull(separator, SEPARATOR);</span>
<span class="fc" id="L843">    Check.that(from, FROM_INDEX).is(gte(), 0).is(lte(), array.length);</span>
<span class="fc bfc" id="L844" title="All 2 branches covered.">    int x = to == -1 ? array.length : Math.min(to, array.length);</span>
<span class="fc" id="L845">    Check.that(x, TO_INDEX).is(gte(), from);</span>
<span class="fc" id="L846">    return Arrays.stream(array, from, x)</span>
<span class="fc" id="L847">          .map(stringifier)</span>
<span class="fc" id="L848">          .collect(joining(separator));</span>
  }

  /**
   * Simply returns the specified array, but allows for leaner code when statically
   * imported.
   *
   * @param objs the array
   * @param &lt;T&gt; the type of the objects to pack
   * @return the same array
   */
  @SafeVarargs
  public static &lt;T&gt; T[] pack(T... objs) {
<span class="fc" id="L861">    return Check.notNull(objs).ok();</span>
  }

  /**
   * Simply returns the specified array, but allows for leaner code when statically
   * imported.
   *
   * @param ints the array
   * @return the same array
   */
  public static int[] ints(int... ints) {
<span class="fc" id="L872">    return Check.notNull(ints).ok();</span>
  }

  /**
   * Simply returns the specified array, but allows for leaner code when statically
   * imported.
   *
   * @param chars the array
   * @return the same array
   */
  public static char[] chars(char... chars) {
<span class="fc" id="L883">    return Check.notNull(chars).ok();</span>
  }

  /**
   * Simply returns the specified array, but allows for leaner code when statically
   * imported.
   *
   * @param doubles the array
   * @return the same array
   */
  public static double[] doubles(double... doubles) {
<span class="fc" id="L894">    return Check.notNull(doubles).ok();</span>
  }

  /**
   * Simply returns the specified array, but allows for leaner code when statically
   * imported.
   *
   * @param longs the array
   * @return the same array
   */
  public static long[] longs(long... longs) {
<span class="fc" id="L905">    return Check.notNull(longs).ok();</span>
  }

  /**
   * Simply returns the specified array, but allows for leaner code when statically
   * imported.
   *
   * @param floats The array
   * @return the same array
   */
  public static float[] floats(float... floats) {
<span class="fc" id="L916">    return Check.notNull(floats).ok();</span>
  }

  /**
   * Prefixes the specified object to the specified array.
   *
   * @param array the array to be prefixed
   * @param obj the object to prefix
   * @param &lt;T&gt; the type of the array elements and the object to be prefixed
   * @return a new array containing the specified object and the elements of the specified
   * array
   */
  public static &lt;T&gt; T[] prefix(T[] array, T obj) {
<span class="fc" id="L929">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L930">    T[] res = fromTemplate(array, array.length + 1);</span>
<span class="fc" id="L931">    res[0] = obj;</span>
<span class="fc" id="L932">    arraycopy(array, 0, res, 1, array.length);</span>
<span class="fc" id="L933">    return res;</span>
  }

  /**
   * Prefixes the specified object to the specified array.
   *
   * @param array the array to be prefixed
   * @param obj0 the 1st object to prefix
   * @param obj1 the 2nd object to prefix
   * @param moreObjs more objects to prefix
   * @param &lt;T&gt; the type of the array elements and the object to be prefixed
   * @return a new array containing the specified objects and the elements of the
   * specified array
   */
  @SafeVarargs
  public static &lt;T&gt; T[] prefix(T[] array, T obj0, T obj1, T... moreObjs) {
<span class="fc" id="L949">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L950">    Check.notNull(moreObjs, VARARGS);</span>
<span class="fc" id="L951">    int sz = array.length + 2 + moreObjs.length;</span>
<span class="fc" id="L952">    T[] res = fromTemplate(array, sz);</span>
<span class="fc" id="L953">    res[0] = obj0;</span>
<span class="fc" id="L954">    res[1] = obj1;</span>
<span class="fc" id="L955">    arraycopy(moreObjs, 0, res, 2, moreObjs.length);</span>
<span class="fc" id="L956">    arraycopy(array, 0, res, 2 + moreObjs.length, array.length);</span>
<span class="fc" id="L957">    return res;</span>
  }

  /**
   * Converts an {@code int} array to a {@code List&lt;Integer&gt;}.
   *
   * @param values the array elements.
   * @return a {@code List} containing the same elements in the same order
   */
  public static List&lt;Integer&gt; asList(int[] values) {
<span class="fc" id="L967">    return Arrays.asList(box(values));</span>
  }

  /**
   * Converts a {@code float} array to a {@code List&lt;Float&gt;}.
   *
   * @param values the array elements.
   * @return a {@code List} containing the same elements in the same order
   */
  public static List&lt;Float&gt; asList(float[] values) {
<span class="fc" id="L977">    return Arrays.asList(box(values));</span>
  }

  /**
   * Converts a {@code double} array to a {@code List&lt;Double&gt;}.
   *
   * @param values the array elements.
   * @return a {@code List} containing the same elements in the same order
   */
  public static List&lt;Double&gt; asList(double[] values) {
<span class="fc" id="L987">    return Arrays.asList(box(values));</span>
  }

  /**
   * Converts a {@code long} array to a {@code List&lt;Long&gt;}.
   *
   * @param values the array elements.
   * @return a {@code List} containing the same elements in the same order
   */
  public static List&lt;Long&gt; asList(long[] values) {
<span class="fc" id="L997">    return Arrays.asList(box(values));</span>
  }

  /**
   * Converts a {@code short} array to a {@code List&lt;Short&gt;}.
   *
   * @param values the array elements.
   * @return a {@code List} containing the same elements in the same order
   */
  public static List&lt;Short&gt; asList(short[] values) {
<span class="fc" id="L1007">    return Arrays.asList(box(values));</span>
  }

  /**
   * Converts a {@code byte} array to a {@code List&lt;Byte&gt;}.
   *
   * @param values the array elements.
   * @return a {@code List} containing the same elements in the same order
   */
  public static List&lt;Byte&gt; asList(byte[] values) {
<span class="fc" id="L1017">    return Arrays.asList(box(values));</span>
  }

  /**
   * Converts a {@code char} array to a {@code List&lt;Character&gt;}.
   *
   * @param values the array elements.
   * @return a {@code List} containing the same elements in the same order
   */
  public static List&lt;Character&gt; asList(char[] values) {
<span class="fc" id="L1027">    return Arrays.asList(box(values));</span>
  }

  /**
   * Converts a {@code boolean} array to a {@code List&lt;Boolean&gt;}.
   *
   * @param values the array elements.
   * @return a {@code List} containing the same elements in the same order
   */
  public static List&lt;Boolean&gt; asList(boolean[] values) {
<span class="fc" id="L1037">    return Arrays.asList(box(values));</span>
  }

  /**
   * Converts an {@code Integer} array to an {@code int} array.
   *
   * @param values the {@code Integer} array
   * @param dfault The {@code int} value to convert {@code null} elements in the source
   * array to
   * @return the {@code int} array
   */
  public static int[] unbox(Integer[] values, int dfault) {
<span class="fc" id="L1049">    Check.notNull(values);</span>
<span class="fc" id="L1050">    return Arrays.stream(values).mapToInt(i -&gt; ifNull(i, dfault)).toArray();</span>
  }

  /**
   * Converts an {@code Integer} array to an {@code int} array. {@code null} elements in
   * the source array are converted to 0 (zero).
   *
   * @param values the {@code Integer} array
   * @return the {@code int} array
   */
  public static int[] unbox(Integer[] values) {
<span class="fc" id="L1061">    return unbox(values, 0);</span>
  }

  /**
   * Converts an {@code int} array to an {@code Integer} array.
   *
   * @param values the {@code int} array
   * @return the {@code Integer} array
   */
  public static Integer[] box(int[] values) {
<span class="fc" id="L1071">    return Check.notNull(values).ok(Arrays::stream).boxed().toArray(Integer[]::new);</span>
  }

  /**
   * Converts a {@code double} array to a {@code Double} array.
   *
   * @param values the {@code double} array
   * @return the {@code Double} array
   */
  public static Double[] box(double[] values) {
<span class="fc" id="L1081">    return Check.notNull(values).ok(Arrays::stream).boxed().toArray(Double[]::new);</span>
  }

  /**
   * Converts a {@code long} array to a {@code Long} array.
   *
   * @param values the {@code long} array
   * @return the {@code Long} array
   */
  public static Long[] box(long[] values) {
<span class="fc" id="L1091">    return Check.notNull(values).ok(Arrays::stream).boxed().toArray(Long[]::new);</span>
  }

  /**
   * Converts a {@code float} array to a {@code Float} array.
   *
   * @param values the {@code float} array
   * @return the {@code Float} array
   */
  public static Float[] box(float[] values) {
<span class="fc" id="L1101">    var res = new Float[Check.notNull(values).ok().length];</span>
<span class="fc bfc" id="L1102" title="All 2 branches covered.">    for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="fc" id="L1103">      res[i] = values[i];</span>
    }
<span class="fc" id="L1105">    return res;</span>
  }

  /**
   * Converts a {@code short} array to a {@code Short} array.
   *
   * @param values the {@code short} array
   * @return the {@code Short} array
   */
  public static Short[] box(short[] values) {
<span class="fc" id="L1115">    var res = new Short[Check.notNull(values).ok().length];</span>
<span class="fc bfc" id="L1116" title="All 2 branches covered.">    for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="fc" id="L1117">      res[i] = values[i];</span>
    }
<span class="fc" id="L1119">    return res;</span>
  }

  /**
   * Converts a {@code byte} array to a {@code Byte} array.
   *
   * @param values the {@code byte} array
   * @return the {@code Byte} array
   */
  public static Byte[] box(byte[] values) {
<span class="fc" id="L1129">    var res = new Byte[Check.notNull(values).ok().length];</span>
<span class="fc bfc" id="L1130" title="All 2 branches covered.">    for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="fc" id="L1131">      res[i] = values[i];</span>
    }
<span class="fc" id="L1133">    return res;</span>
  }

  /**
   * Converts a {@code char} array to a {@code Character} array.
   *
   * @param values the {@code char} array
   * @return the {@code Character} array
   */
  public static Character[] box(char[] values) {
<span class="fc" id="L1143">    var res = new Character[Check.notNull(values).ok().length];</span>
<span class="fc bfc" id="L1144" title="All 2 branches covered.">    for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="fc" id="L1145">      res[i] = values[i];</span>
    }
<span class="fc" id="L1147">    return res;</span>
  }

  /**
   * Converts a {@code boolean} array to a {@code Boolean} array.
   *
   * @param values the {@code boolean} array
   * @return the {@code Boolean} array
   */
  public static Boolean[] box(boolean[] values) {
<span class="fc" id="L1157">    var res = new Boolean[Check.notNull(values).ok().length];</span>
<span class="fc bfc" id="L1158" title="All 2 branches covered.">    for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="fc" id="L1159">      res[i] = values[i];</span>
    }
<span class="fc" id="L1161">    return res;</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  private static &lt;T&gt; T[] fromTemplate(T[] template, int length) {
<span class="fc" id="L1166">    return (T[]) newArray(template.getClass(), length);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>