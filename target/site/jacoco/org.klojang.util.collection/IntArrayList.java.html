<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IntArrayList.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Klojang Check</a> &gt; <a href="index.source.html" class="el_package">org.klojang.util.collection</a> &gt; <span class="el_source">IntArrayList.java</span></div><h1>IntArrayList.java</h1><pre class="source lang-java linenums">package org.klojang.util.collection;

import org.klojang.check.Check;
import org.klojang.check.CommonChecks;
import org.klojang.check.fallible.FallibleIntConsumer;
import org.klojang.util.ArrayMethods;
import org.klojang.util.util.ResizeMethod;

import java.util.*;
import java.util.function.IntConsumer;
import java.util.stream.IntStream;

import static java.lang.System.arraycopy;
import static org.klojang.check.Check.fail;
import static org.klojang.check.CommonChecks.*;
import static org.klojang.check.CommonExceptions.indexOutOfBounds;
import static org.klojang.util.ArrayMethods.*;
import static org.klojang.util.util.ResizeMethod.*;

/**
 * A mutable list of {@code int} values.
 *
 * @author Ayco Holleman
 */
public final class IntArrayList implements IntList {

  private final ResizeMethod resizeMethod;
  private final float resizeAmount;

  int[] buf;
  int size;

  /**
   * Creates an {@code IntList} with an initial capacity of 10.
   */
  public IntArrayList() {
<span class="fc" id="L37">    this(10);</span>
<span class="fc" id="L38">  }</span>

  /**
   * Creates an {@code IntList} with the specified initial capacity. Each time the
   * backing array reaches full capacity, it is resized to twice its length.
   * (However, see {@link ResizeMethod}.)
   *
   * @param initialCapacity The initial capacity of the list
   */
  public IntArrayList(int initialCapacity) {
<span class="fc" id="L48">    this(initialCapacity, MULTIPLY, 2);</span>
<span class="fc" id="L49">  }</span>

  /**
   * Creates an {@code IntList} with the specified initial capacity. Each time the
   * backing array reaches full capacity, it is enlarged by the specified amount.
   *
   * @param initialCapacity The initial capacity of the list
   * @param resizeAmount The (fixed) amount by which to enlarge it when it fills
   *     up
   */
  public IntArrayList(int initialCapacity, int resizeAmount) {
<span class="fc" id="L60">    this(initialCapacity, ADD, resizeAmount);</span>
<span class="fc" id="L61">  }</span>

  /**
   * Creates an {@code IntList} with the specified initial capacity. Each time the
   * backing array reaches full capacity, it is resized by applying the specified
   * {@link ResizeMethod} to the specified resize amount.
   *
   * @param initialCapacity The initial capacity of the list
   * @param resizeMethod The method to use for resizing the backing array
   * @param resizeAmount The resize amount
   */
  public IntArrayList(int initialCapacity,
      ResizeMethod resizeMethod,
<span class="fc" id="L74">      float resizeAmount) {</span>
<span class="fc" id="L75">    Check.that(initialCapacity, &quot;initialCapacity&quot;).is(gte(), 0);</span>
<span class="fc" id="L76">    Check.notNull(resizeMethod, &quot;resizeMethod&quot;);</span>
<span class="fc" id="L77">    this.buf = new int[initialCapacity];</span>
<span class="fc" id="L78">    this.resizeMethod = resizeMethod;</span>
<span class="fc" id="L79">    this.resizeAmount = resizeAmount;</span>
<span class="fc" id="L80">  }</span>

  /**
   * Copy constructor. Creates a new {@code IntList} containing the same values as
   * the specified {@code IntList}.
   *
   * @param other The {@code IntList} to copy
   */
<span class="fc" id="L88">  public IntArrayList(IntList other) {</span>
<span class="fc" id="L89">    Check.notNull(other, &quot;IntList&quot;);</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">    if (other instanceof IntArrayList ial) {</span>
<span class="fc" id="L91">      this.size = ial.size;</span>
<span class="fc" id="L92">      this.resizeMethod = ial.resizeMethod;</span>
<span class="fc" id="L93">      this.resizeAmount = ial.resizeAmount;</span>
<span class="fc" id="L94">      this.buf = new int[Math.min(Integer.MAX_VALUE, size + 10)];</span>
<span class="fc" id="L95">      arraycopy(ial.buf, 0, this.buf, 0, size);</span>
    } else { // UnmodifiableIntList
<span class="fc" id="L97">      this.buf = other.toArray();</span>
<span class="fc" id="L98">      this.size = other.size();</span>
<span class="fc" id="L99">      this.resizeMethod = MULTIPLY;</span>
<span class="fc" id="L100">      this.resizeAmount = 2F;</span>
    }
<span class="fc" id="L102">  }</span>

  @Override
  public int get(int index) {
<span class="fc" id="L106">    checkIndex(index);</span>
<span class="fc" id="L107">    return buf[index];</span>
  }

  @Override
  public void set(int index, int value) {
<span class="fc" id="L112">    checkIndex(index);</span>
<span class="fc" id="L113">    buf[index] = value;</span>
<span class="fc" id="L114">  }</span>

  @Override
  public OptionalInt indexOf(int value) {
<span class="fc bfc" id="L118" title="All 2 branches covered.">    for (int x = 0; x &lt; size; ++x) {</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">      if (buf[x] == value) {</span>
<span class="fc" id="L120">        return OptionalInt.of(x);</span>
      }
    }
<span class="fc" id="L123">    return OptionalInt.empty();</span>
  }

  @Override
  public OptionalInt lastIndexOf(int value) {
<span class="fc bfc" id="L128" title="All 2 branches covered.">    for (int x = size - 1; x &gt;= 0; --x) {</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">      if (buf[x] == value) {</span>
<span class="fc" id="L130">        return OptionalInt.of(x);</span>
      }
    }
<span class="fc" id="L133">    return OptionalInt.empty();</span>
  }

  @Override
  public void add(int value) {
<span class="fc" id="L138">    add(size, value);</span>
<span class="fc" id="L139">  }</span>

  @Override
  public void add(int index, int value) {
<span class="fc" id="L143">    checkIndexInclusive(index);</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">    if (size == buf.length) {</span>
<span class="fc" id="L145">      increaseCapacity(1);</span>
    }
<span class="fc bfc" id="L147" title="All 2 branches covered.">    if (index != size) {</span>
<span class="fc" id="L148">      arraycopy(buf, index, buf, index + 1, size - index);</span>
    }
<span class="fc" id="L150">    buf[index] = value;</span>
<span class="fc" id="L151">    ++size;</span>
<span class="fc" id="L152">  }</span>

  @Override
  public void addAll(IntList other) {
<span class="fc" id="L156">    addAll(size, other);</span>
<span class="fc" id="L157">  }</span>

  @Override
  public void addAll(int[] values) {
<span class="fc" id="L161">    addAll(size, values);</span>
<span class="fc" id="L162">  }</span>

  @Override
  public void addAll(int index, IntList other) {
<span class="fc" id="L166">    checkIndexInclusive(index);</span>
<span class="fc" id="L167">    Check.notNull(other);</span>
<span class="fc" id="L168">    int minIncrease = getMinIncrease(buf.length, size, other.size());</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">    if (minIncrease &gt; 0) {</span>
<span class="fc" id="L170">      increaseCapacity(minIncrease);</span>
    }
<span class="fc bfc" id="L172" title="All 2 branches covered.">    if (index != size) {</span>
<span class="fc" id="L173">      arraycopy(buf, index, buf, index + other.size(), size - index);</span>
    }
<span class="fc" id="L175">    arraycopy(getBuffer(other), 0, buf, index, other.size());</span>
<span class="fc" id="L176">    size += other.size();</span>
<span class="fc" id="L177">  }</span>

  @Override
  public void addAll(int index, int[] values) {
<span class="fc" id="L181">    checkIndexInclusive(index);</span>
<span class="fc" id="L182">    Check.notNull(values);</span>
<span class="fc" id="L183">    int minIncrease = getMinIncrease(buf.length, size, values.length);</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">    if (minIncrease &gt; 0) {</span>
<span class="fc" id="L185">      increaseCapacity(minIncrease);</span>
    }
<span class="fc bfc" id="L187" title="All 2 branches covered.">    if (index != size) {</span>
<span class="fc" id="L188">      arraycopy(buf, index, buf, index + values.length, size - index);</span>
    }
<span class="fc" id="L190">    arraycopy(values, 0, buf, index, values.length);</span>
<span class="fc" id="L191">    size += values.length;</span>
<span class="fc" id="L192">  }</span>

  @Override
  public void removeByIndex(int index) {
<span class="fc" id="L196">    checkIndex(index);</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">    if (index != size - 1) {</span>
<span class="fc" id="L198">      System.arraycopy(buf, index + 1, buf, index, size - 1 - index);</span>
    }
<span class="fc" id="L200">    --size;</span>
<span class="fc" id="L201">  }</span>

  @Override
  public boolean removeByValue(int value) {
<span class="fc" id="L205">    OptionalInt index = indexOf(value);</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">    if (index.isPresent()) {</span>
<span class="fc" id="L207">      removeByIndex(index.getAsInt());</span>
<span class="fc" id="L208">      return true;</span>
    }
<span class="fc" id="L210">    return false;</span>
  }

  @Override
  public boolean removeAll(IntList list) {
<span class="fc" id="L215">    Check.notNull(list);</span>
<span class="fc" id="L216">    return removeAll(list.toGenericList());</span>
  }

  @Override
  public boolean removeAll(int... values) {
<span class="fc" id="L221">    Check.notNull(values);</span>
<span class="fc" id="L222">    return removeAll(ArrayMethods.asList(values));</span>
  }

  @Override
  public boolean removeAll(Collection&lt;?&gt; c) {
<span class="fc" id="L227">    Check.notNull(c);</span>
<span class="fc" id="L228">    Set&lt;Integer&gt; set = new LinkedHashSet&lt;&gt;(toGenericList());</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">    if (set.removeAll(c)) {</span>
<span class="fc" id="L230">      buf = unbox(set.toArray(Integer[]::new));</span>
<span class="fc" id="L231">      size = set.size();</span>
<span class="fc" id="L232">      return true;</span>
    }
<span class="fc" id="L234">    return false;</span>
  }

  @Override
  public boolean retainAll(IntList list) {
<span class="fc" id="L239">    Check.notNull(list);</span>
<span class="fc" id="L240">    return retainAll(list.toGenericList());</span>
  }

  @Override
  public boolean retainAll(int... values) {
<span class="fc" id="L245">    Check.notNull(values);</span>
<span class="fc" id="L246">    return retainAll(ArrayMethods.asList(values));</span>
  }

  @Override
  public boolean retainAll(Collection&lt;?&gt; c) {
<span class="fc" id="L251">    Check.notNull(c);</span>
<span class="fc" id="L252">    Set&lt;Integer&gt; set = new LinkedHashSet&lt;&gt;(toGenericList());</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">    if (set.retainAll(c)) {</span>
<span class="fc" id="L254">      buf = unbox(set.toArray(Integer[]::new));</span>
<span class="fc" id="L255">      size = set.size();</span>
<span class="fc" id="L256">      return true;</span>
    }
<span class="fc" id="L258">    return false;</span>
  }

  @Override
  public int size() {
<span class="fc" id="L263">    return size;</span>
  }

  @Override
  public int capacity() {
<span class="fc" id="L268">    return buf.length;</span>
  }

  @Override
  public void setCapacity(int newCapacity) {
<span class="fc bfc" id="L273" title="All 2 branches covered.">    if (newCapacity != buf.length) {</span>
<span class="fc" id="L274">      Check.that(newCapacity, &quot;new capacity&quot;)</span>
<span class="fc" id="L275">          .is(gte(), 0)</span>
<span class="fc" id="L276">          .is(lte(), Integer.MAX_VALUE);</span>
<span class="fc" id="L277">      size = Math.min(size, newCapacity);</span>
<span class="fc" id="L278">      int[] newBuf = new int[newCapacity];</span>
<span class="fc" id="L279">      arraycopy(buf, 0, newBuf, 0, size);</span>
<span class="fc" id="L280">      buf = newBuf;</span>
    }
<span class="fc" id="L282">  }</span>

  @Override
  public void sort() {
<span class="fc" id="L286">    Arrays.sort(buf, 0, size);</span>
<span class="fc" id="L287">  }</span>

  @Override
  public void sortDescending() {
<span class="fc" id="L291">    sort();</span>
    // Not ideal, but OK for now
<span class="fc" id="L293">    ArrayMethods.reverse(buf, 0, size);</span>
<span class="fc" id="L294">  }</span>

  @Override
  public boolean isEmpty() {
<span class="fc bfc" id="L298" title="All 2 branches covered.">    return size == 0;</span>
  }

  @Override
  public void clear() {
<span class="fc" id="L303">    size = 0;</span>
<span class="fc" id="L304">  }</span>

  @Override
  public void trim(int newSize) {
<span class="fc" id="L308">    size = Check.that(newSize, &quot;new size&quot;).is(gte(), 0).is(lte(), size).ok();</span>
<span class="fc" id="L309">  }</span>

  @Override
  public int[] toArray() {
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">    if (size == 0) {</span>
<span class="nc" id="L314">      return EMPTY_INT_ARRAY;</span>
    }
<span class="fc" id="L316">    int[] b = new int[size];</span>
<span class="fc" id="L317">    arraycopy(buf, 0, b, 0, size);</span>
<span class="fc" id="L318">    return b;</span>
  }

  @Override
  public int[] toArray(int from, int to) {
<span class="nc" id="L323">    int len = Check.fromTo(size, from, to);</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">    if ((size | len) == 0) {</span>
<span class="nc" id="L325">      return EMPTY_INT_ARRAY;</span>
    }
<span class="nc" id="L327">    int[] b = new int[len];</span>
<span class="nc" id="L328">    arraycopy(buf, 0, b, 0, len);</span>
<span class="nc" id="L329">    return b;</span>
  }

  @Override
  public List&lt;Integer&gt; toGenericList() {
<span class="fc" id="L334">    return List.of(box(buf));</span>
  }

  @Override
  public IntStream stream() {
<span class="fc" id="L339">    return Arrays.stream(buf, 0, size);</span>
  }

  @Override
  public void forEach(IntConsumer action) {
<span class="fc" id="L344">    stream().forEach(action);</span>
<span class="fc" id="L345">  }</span>

  @Override
  public &lt;E extends Throwable&gt; void forEachThrowing(FallibleIntConsumer&lt;E&gt; action)
      throws E {
<span class="fc bfc" id="L350" title="All 2 branches covered.">    for (int i : buf) {</span>
<span class="fc" id="L351">      action.accept(i);</span>
    }
<span class="fc" id="L353">  }</span>

  @Override
  public boolean equals(Object obj) {
<span class="fc bfc" id="L357" title="All 2 branches covered.">    if (this == obj) {</span>
<span class="fc" id="L358">      return true;</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">    } else if (obj == null) {</span>
<span class="fc" id="L360">      return false;</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">    } else if (obj instanceof IntList il) {</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">      return size == il.size()</span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">          &amp;&amp; Arrays.equals(buf, 0, size, getBuffer(il), 0, size);</span>
    }
<span class="fc" id="L365">    return false;</span>
  }

  @Override
  public int hashCode() {
<span class="fc" id="L370">    int hash = buf[0];</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">    for (int i = 1; i &lt; size; ++i) {</span>
<span class="fc" id="L372">      hash = hash * 31 + buf[i];</span>
    }
<span class="fc" id="L374">    return hash;</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L379">    return '[' + implodeInts(buf, size) + ']';</span>
  }

  private void increaseCapacity(int minIncrease) {
<span class="fc" id="L383">    int capacity = resizeMethod.resize(buf.length, resizeAmount, minIncrease);</span>
<span class="fc" id="L384">    int[] newBuf = new int[capacity];</span>
<span class="fc" id="L385">    arraycopy(buf, 0, newBuf, 0, size);</span>
<span class="fc" id="L386">    buf = newBuf;</span>
<span class="fc" id="L387">  }</span>

  private static int[] getBuffer(IntList other) {
    // IntList is sealed, and as far as we know only permits
    // IntArrayList and UnmodifiableIntList
<span class="fc bfc" id="L392" title="All 2 branches covered.">    return other instanceof IntArrayList ial</span>
<span class="fc" id="L393">        ? ial.buf</span>
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">        : other instanceof UnmodifiableIntList uil</span>
<span class="fc" id="L395">            ? uil.buf</span>
<span class="nc" id="L396">            : fail(AssertionError::new);</span>
  }

  private void checkIndex(int index) {
<span class="fc" id="L400">    Check.that(index).is(CommonChecks.indexOf(), buf, indexOutOfBounds(index));</span>
<span class="fc" id="L401">  }</span>

  private void checkIndexInclusive(int index) {
<span class="fc" id="L404">    Check.that(index).is(indexInclusiveOf(), buf, indexOutOfBounds(index));</span>
<span class="fc" id="L405">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>