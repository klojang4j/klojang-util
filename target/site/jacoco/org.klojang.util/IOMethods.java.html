<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IOMethods.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Klojang Check</a> &gt; <a href="index.source.html" class="el_package">org.klojang.util</a> &gt; <span class="el_source">IOMethods.java</span></div><h1>IOMethods.java</h1><pre class="source lang-java linenums">package org.klojang.util;

import java.io.*;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.concurrent.atomic.AtomicLong;

import org.klojang.check.Check;
import org.klojang.util.ExceptionMethods;
import org.klojang.util.IOMethods;
import org.klojang.util.x.Param;

import static java.nio.charset.StandardCharsets.UTF_8;
import static java.nio.file.StandardOpenOption.*;
import static org.klojang.check.CommonChecks.*;
import static org.klojang.check.CommonExceptions.IO;
import static org.klojang.util.ObjectMethods.isEmpty;
import static org.klojang.util.StringMethods.*;
import static org.klojang.util.x.Param.*;

/**
 * I/O-related methods.
 *
 * @author Ayco Holleman
 */
public class IOMethods {

  private static final String INVALID_PATH = &quot;No such resource: \&quot;${0}\&quot;&quot;;

  // parameter names:
  private static final String CONTENTS = &quot;contents&quot;;
  private static final String CHUNK_SIZE = &quot;chunkSize&quot;;
  private static final String REQUESTER = &quot;requester&quot;;

  private static final String DOT = &quot;.&quot;;

<span class="nc" id="L40">  private IOMethods() {</span>
<span class="nc" id="L41">    throw new UnsupportedOperationException();</span>
  }

  /**
   * Returns the contents of the specified file.
   *
   * @param path the path to the file
   * @return the contents of the specified file
   */
  public static String getContents(String path) {
<span class="fc" id="L51">    Check.notNull(path, PATH);</span>
<span class="fc" id="L52">    File f = Check.that(new File(path)).is(regularFile()).ok();</span>
<span class="fc" id="L53">    try (FileInputStream fis = new FileInputStream(f)) {</span>
<span class="fc" id="L54">      return getContents(fis);</span>
<span class="nc" id="L55">    } catch (IOException e) {</span>
<span class="nc" id="L56">      throw ExceptionMethods.uncheck(e);</span>
    }
  }

  /**
   * Returns the contents of the specified resource. Bytes are read in chunks of 512
   * bytes.
   *
   * @param clazz the {@code Class} to call
   *     {@link Class#getResourceAsStream(String) getResourceAsStream} on
   * @param path the path to the resource
   * @return the contents of the specified resource
   */
  public static String getContents(Class&lt;?&gt; clazz, String path) {
<span class="fc" id="L70">    return getContents(clazz, path, 512);</span>
  }

  /**
   * Returns the contents of the specified resource.
   *
   * @param clazz the {@code Class} to call
   *     {@link Class#getResourceAsStream(String) getResourceAsStream} on
   * @param path the path to the resource
   * @param chunkSize the number of bytes to read at a time
   * @return the contents of the specified resource
   */
  public static String getContents(Class&lt;?&gt; clazz, String path, int chunkSize) {
<span class="fc" id="L83">    Check.that(clazz, CLAZZ).is(notNull()).and(path, PATH).is(notNull());</span>
<span class="fc" id="L84">    try (InputStream in = clazz.getResourceAsStream(path)) {</span>
<span class="fc" id="L85">      Check.that(in).is(notNull(), INVALID_PATH, path);</span>
<span class="fc" id="L86">      return getContents(in, chunkSize);</span>
<span class="nc" id="L87">    } catch (IOException e) {</span>
<span class="nc" id="L88">      throw ExceptionMethods.uncheck(e);</span>
    }
  }

  /**
   * Returns a {@code String} created from the bytes read from the specified input
   * stream. Bytes are read in chunks of 512 bytes. The input stream is &lt;i&gt;not&lt;/i&gt;
   * closed once all bytes have been read.
   *
   * @param in the input stream
   * @return a {@code String} from the bytes read from the specified input stream
   */
  public static String getContents(InputStream in) {
<span class="fc" id="L101">    return getContents(in, 512);</span>
  }

  /**
   * Returns a {@code String} created from the bytes read from the specified input
   * stream. The input stream is &lt;i&gt;not&lt;/i&gt; closed once all bytes have been read.
   *
   * @param in the input stream
   * @param chunkSize the number of bytes to read at a time
   * @return a {@code String} from the bytes read from the specified input stream
   */
  public static String getContents(InputStream in, int chunkSize) {
<span class="fc" id="L113">    Check.that(chunkSize, CHUNK_SIZE).is(gt(), 0);</span>
<span class="fc" id="L114">    ByteArrayOutputStream out = new ByteArrayOutputStream(chunkSize);</span>
<span class="fc" id="L115">    pipe(in, out, chunkSize);</span>
<span class="fc" id="L116">    return out.toString(UTF_8);</span>
  }

  /**
   * Simple file-write method. Not efficient, but easy to use. Overwrites
   * pre-existing contents.
   *
   * @param path the path to the file
   * @param contents The contents to be written
   */
  public static void write(String path, String contents) {
<span class="fc" id="L127">    Check.that(path, PATH).is(notNull()).and(contents, CONTENTS).is(notNull());</span>
    try {
<span class="fc" id="L129">      Files.writeString(Path.of(path), contents, UTF_8, CREATE, TRUNCATE_EXISTING);</span>
<span class="nc" id="L130">    } catch (IOException e) {</span>
<span class="nc" id="L131">      throw ExceptionMethods.uncheck(e);</span>
<span class="fc" id="L132">    }</span>
<span class="fc" id="L133">  }</span>

  /**
   * Simple file-write method. Not efficient, but easy to use. Appends the specified
   * string to the contents of the specified file.
   *
   * @param path the path to the file
   * @param contents The contents to be written
   */
  public static void append(String path, String contents) {
<span class="fc" id="L143">    Check.that(path, PATH).is(notNull()).and(contents, CONTENTS).is(notNull());</span>
    try {
<span class="fc" id="L145">      Files.writeString(Path.of(path), contents, UTF_8, CREATE, APPEND);</span>
<span class="nc" id="L146">    } catch (IOException e) {</span>
<span class="nc" id="L147">      throw ExceptionMethods.uncheck(e);</span>
<span class="fc" id="L148">    }</span>
<span class="fc" id="L149">  }</span>

  /**
   * Returns the contents of the specified resource as a byte array. Bytes are read
   * in chunks of 512 bytes.
   *
   * @param clazz the {@code Class} to call
   *     {@link Class#getResourceAsStream(String) getResourceAsStream} on
   * @param path the path to the resource
   * @return the bytes contained in the specified resource
   */
  public static byte[] readBytes(Class&lt;?&gt; clazz, String path) {
<span class="fc" id="L161">    return readBytes(clazz, path, 512);</span>
  }

  /**
   * Returns the contents of the specified resource as a byte array.
   *
   * @param clazz the {@code Class} to call
   *     {@link Class#getResourceAsStream(String) getResourceAsStream} on
   * @param path the path to the resource
   * @param chunkSize the number of bytes to read at a time
   * @return the contents of the specified resource
   */
  public static byte[] readBytes(Class&lt;?&gt; clazz, String path, int chunkSize) {
<span class="fc" id="L174">    Check.that(clazz, CLAZZ).is(notNull()).and(path, PATH).is(notNull());</span>
<span class="fc" id="L175">    try (InputStream in = clazz.getResourceAsStream(path)) {</span>
<span class="fc" id="L176">      Check.that(in).is(notNull(), INVALID_PATH, path);</span>
<span class="fc" id="L177">      return readBytes(in, chunkSize);</span>
<span class="nc" id="L178">    } catch (IOException e) {</span>
<span class="nc" id="L179">      throw ExceptionMethods.uncheck(e);</span>
    }
  }

  /**
   * Returns a {@code byte[]} array containing the bytes read from the specified
   * input stream. Bytes are read in chunks of 512 bytes. &lt;i&gt;The input stream is not
   * closed by this method.&lt;/i&gt;
   *
   * @param in the input stream
   * @return a {@code byte[]} array containing the bytes read from the specified
   *     input stream
   */
  public static byte[] readBytes(InputStream in) {
<span class="fc" id="L193">    return readBytes(in, 512);</span>
  }

  /**
   * Returns a {@code byte[]} array containing the bytes read from the specified
   * input stream. Bytes are read in chunks of the specified size. &lt;i&gt;The input
   * stream is not closed by this method.&lt;/i&gt;
   *
   * @param in the input stream
   * @param chunkSize the number of bytes to read at a time
   * @return a {@code byte[]} array containing the bytes read from the specified
   *     input stream
   */
  public static byte[] readBytes(InputStream in, int chunkSize) {
<span class="fc" id="L207">    ByteArrayOutputStream out = new ByteArrayOutputStream(chunkSize);</span>
<span class="fc" id="L208">    pipe(in, out, chunkSize);</span>
<span class="fc" id="L209">    return out.toByteArray();</span>
  }

  /**
   * Reads all bytes from the specified input stream and writes them to the specified
   * output stream. Bytes are read and written in chunks of 512 bytes at a time.
   * &lt;i&gt;The input stream and the output stream are not closed by this method.&lt;/i&gt;
   *
   * @param in the input stream
   * @param out the output stream
   */
  public static void pipe(InputStream in, OutputStream out) {
<span class="fc" id="L221">    pipe(in, out, 512);</span>
<span class="fc" id="L222">  }</span>

  /**
   * Reads all bytes from the specified input stream and writes them to the specified
   * output stream. Bytes are read and written in chunks of the specified size.
   * &lt;i&gt;The input stream and the output stream are not closed by this method.&lt;/i&gt;
   *
   * @param in the input stream
   * @param out the output stream
   * @param chunkSize the number of bytes read/written at a time
   */
  public static void pipe(InputStream in, OutputStream out, int chunkSize) {
<span class="fc" id="L234">    Check.that(in, IN).is(notNull())</span>
<span class="fc" id="L235">        .and(out, OUT).is(notNull())</span>
<span class="fc" id="L236">        .and(chunkSize, CHUNK_SIZE).is(gt(), 0);</span>
<span class="fc" id="L237">    byte[] data = new byte[chunkSize];</span>
    try {
<span class="fc" id="L239">      int n = in.read(data, 0, data.length);</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">      while (n != -1) {</span>
<span class="fc" id="L241">        out.write(data, 0, n);</span>
<span class="fc" id="L242">        out.flush();</span>
<span class="fc" id="L243">        n = in.read(data, 0, data.length);</span>
      }
<span class="nc" id="L245">    } catch (IOException e) {</span>
<span class="nc" id="L246">      throw ExceptionMethods.uncheck(e);</span>
<span class="fc" id="L247">    }</span>
<span class="fc" id="L248">  }</span>

  /**
   * Creates a new, empty file in the file system's temp directory. Equivalent to:
   *
   * &lt;blockquote&gt;&lt;pre&gt;{@code
   * createTempFile(IOMethods.class, &quot;.tmp&quot;, true)
   * }&lt;/pre&gt;&lt;/blockquote&gt;
   *
   * @return a {@code File} object for a new, empty file in the file system's temp
   *     directory
   * @throws IOException if an I/O error occurs
   */
  public static File createTempFile() throws IOException {
<span class="fc" id="L262">    return createTempFile(IOMethods.class);</span>
  }

  /**
   * Creates a new, empty file in the file system's temp directory. Equivalent to:
   *
   * &lt;blockquote&gt;&lt;pre&gt;{@code
   * createTempFile(requester &quot;.tmp&quot;, true)
   * }&lt;/pre&gt;&lt;/blockquote&gt;
   *
   * @param requester the class requesting the temp file (its simple name will
   *     become part of the file name)
   * @return a {@code File} object for a new, empty file in the file system's temp
   *     directory
   * @throws IOException if an I/O error occurs
   */
  public static File createTempFile(Class&lt;?&gt; requester) throws IOException {
<span class="fc" id="L279">    return createTempFile(requester, true);</span>
  }

  /**
   * Creates a {@code File} object with a unique file name, located file system's
   * temp directory. Equivalent to:
   *
   * &lt;blockquote&gt;&lt;pre&gt;{@code
   * createTempFile(requester &quot;tmp&quot;, touch)
   * }&lt;/pre&gt;&lt;/blockquote&gt;
   *
   * @param requester the class requesting the temp file (its simple name will
   *     become part of the file name)
   * @param touch whether to actually create the file on the file system
   * @return a {@code File} object for a new, empty file in the file system's temp
   *     directory
   * @throws IOException if an I/O error occurs
   */
  public static File createTempFile(Class&lt;?&gt; requester, boolean touch)
      throws IOException {
<span class="fc" id="L299">    return createTempFile(requester, &quot;.tmp&quot;, touch);</span>
  }

  /**
   * Creates a {@code File} object with a unique file name, located in file system's
   * temp directory.
   *
   * @param requester the class requesting the temp file (its simple name will
   *     become part of the file name)
   * @param extension the extension to append to the generated directory name. If
   *     empty or {@code null}, no extension will be appended to the file name.
   *     Otherwise the extension may or may not start with &quot;.&quot; (the dot will be
   *     prepended if absent).
   * @param touch whether to actually create the file on the file system
   * @return a {@code File} object for a new, empty file in the file system's temp
   *     directory
   * @throws IOException if an I/O error occurs
   */
  public static File createTempFile(Class&lt;?&gt; requester,
      String extension,
      boolean touch)
      throws IOException {
<span class="fc" id="L321">    Check.notNull(requester, REQUESTER);</span>
<span class="fc" id="L322">    return doCreateTempFile(requester, File.separator, extension, touch);</span>
  }

  /**
   * Creates a {@code File} object with a unique file name, located in file system's
   * temp directory.
   *
   * @param requester the class requesting the temp directory (its simple name
   *     will become part of the file name)
   * @param relativePath any intermediate directories between the file system's
   *     temp directory and the file to be created. &quot;/&quot; means the file will be
   *     created directly underneath the file system's temp directory. Intermediate
   *     directories will be created if necessary. If the path does not start and/or
   *     end with &quot;/&quot; ({@link File#separator}), it will be prepended resp. appended.
   * @param extension the extension to append to the generated directory name. If
   *     empty or {@code null}, no extension will be appended to the directory name.
   *     Otherwise the extension may or may not start with &quot;.&quot; (the dot will be
   *     prepended if absent).
   * @param touch whether to actually create the directory on the file system
   * @return a {@code File} object for a new, empty file in the file system's temp
   *     directory
   * @throws IOException if an I/O error occurs
   */
  public static File createTempFile(
      Class&lt;?&gt; requester, String relativePath, String extension, boolean touch)
      throws IOException {
<span class="fc" id="L348">    Check.notNull(requester, REQUESTER);</span>
<span class="fc" id="L349">    Check.notNull(relativePath, Param.RELATIVE_PATH);</span>
<span class="fc" id="L350">    return doCreateTempFile(requester, relativePath, extension, touch);</span>
  }

  /**
   * Creates a new, empty directory under the file system's temp directory.
   * Equivalent to:
   *
   * &lt;blockquote&gt;&lt;pre&gt;{@code
   * createTempFile(requester &quot;.d&quot;, true)
   * }&lt;/pre&gt;&lt;/blockquote&gt;
   *
   * @return a {@code File} object for a new, empty directory in the file system's
   *     temp directory
   * @throws IOException if an I/O error occurs
   */
  public static File createTempDir() throws IOException {
<span class="nc" id="L366">    return createTempDir(IOMethods.class);</span>
  }

  /**
   * Creates a new, empty directory under the file system's temp directory.
   * Equivalent to:
   *
   * &lt;blockquote&gt;&lt;pre&gt;{@code
   * createTempFile(requester, &quot;.d&quot;, true)
   * }&lt;/pre&gt;&lt;/blockquote&gt;
   *
   * @param requester the class requesting the temp file (its simple name will
   *     become part of the file name)
   * @return a {@code File} object for a new, empty file in the file system's temp
   *     directory
   * @throws IOException if an I/O error occurs
   */
  public static File createTempDir(Class&lt;?&gt; requester) throws IOException {
<span class="nc" id="L384">    return createTempDir(requester, true);</span>
  }

  /**
   * Creates a {@code File} object with a unique file name, located file system's
   * temp directory. Equivalent to:
   *
   * &lt;blockquote&gt;&lt;pre&gt;{@code
   * createTempDir(requester &quot;.d&quot;, touch)
   * }&lt;/pre&gt;&lt;/blockquote&gt;
   *
   * @param requester the class requesting the temp directory (its simple name
   *     will become part of the file name)
   * @param touch whether to actually create the directory on the file system
   * @return a {@code File} object for a new, empty directory in the file system's
   *     temp directory
   * @throws IOException if an I/O error occurs
   */
  public static File createTempDir(Class&lt;?&gt; requester, boolean touch)
      throws IOException {
<span class="nc" id="L404">    Check.notNull(requester, REQUESTER);</span>
<span class="nc" id="L405">    return doCreateTempDir(requester, File.separator, &quot;.d&quot;, touch);</span>
  }

  /**
   * Creates a {@code File} object with a unique file name, located in file system's
   * temp directory. If {@code touch} equals {@code true}, the {@code File} object
   * will be used to create a directory underneath the temp directory.
   *
   * @param requester the class requesting the temp directory (its simple name
   *     will become part of the file name)
   * @param extension the extension to append to the generated directory name. If
   *     empty or {@code null}, no extension will be appended to the directory name.
   *     Otherwise the extension may or may not start with &quot;.&quot; (the dot will be
   *     prepended if absent).
   * @param touch whether to actually create the directory on the file system
   * @return a {@code File} object for a new, empty directory in the file system's
   *     temp directory
   * @throws IOException if an I/O error occurs
   */
  public static File createTempDir(Class&lt;?&gt; requester,
      String extension,
      boolean touch)
      throws IOException {
<span class="fc" id="L428">    Check.notNull(requester, REQUESTER);</span>
<span class="fc" id="L429">    return doCreateTempDir(requester, File.separator, extension, touch);</span>
  }

  /**
   * Creates a {@code File} object with a unique file name, located in file system's
   * temp directory. If {@code touch} equals {@code true}, the {@code File} object
   * will be used to create a directory underneath the temp directory.
   *
   * @param requester the class requesting the temp directory (its simple name
   *     will become part of the file name)
   * @param relativePath any intermediate directories between the file system's
   *     temp directory and the directory to be created. &quot;/&quot; means the directory will
   *     be created directly underneath the file system's temp directory.
   *     Intermediate directories will be created if necessary. If the path does not
   *     start or end with &quot;/&quot; ({@link File#separator}), it will be prepended resp.
   *     appended.
   * @param extension the extension to append to the generated directory name. If
   *     empty or {@code null}, no extension will be appended to the directory name.
   *     Otherwise the extension may or may not start with &quot;.&quot; (the dot will be
   *     prepended if absent).
   * @param touch whether to actually create the directory on the file system
   * @return a {@code File} object for a new, empty directory in the file system's
   *     temp directory
   * @throws IOException if an I/O error occurs
   */
  public static File createTempDir(
      Class&lt;?&gt; requester, String relativePath, String extension, boolean touch)
      throws IOException {
<span class="fc" id="L457">    Check.notNull(requester, REQUESTER);</span>
<span class="fc" id="L458">    Check.notNull(relativePath, Param.RELATIVE_PATH);</span>
<span class="fc" id="L459">    return doCreateTempDir(requester, relativePath, extension, touch);</span>
  }

  /**
   * Deletes a file or directory. Directories need not be empty. If the file or
   * directory does not exist, this method returns quietly.
   *
   * @param path the path of the file/directory to be deleted
   */
  public static void rm(String path) {
<span class="fc" id="L469">    Path p = Check.notNull(path).ok(Path::of);</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">    if (Files.exists(p)) {</span>
      try {
<span class="fc" id="L472">        rm(p);</span>
<span class="nc" id="L473">      } catch (IOException e) {</span>
<span class="nc" id="L474">        throw ExceptionMethods.uncheck(e);</span>
<span class="fc" id="L475">      }</span>
    }
<span class="fc" id="L477">  }</span>

  /**
   * Deletes a file or directory. Directories need not be empty. If the file or
   * directory does not exist, this method returns quietly.
   *
   * @param file The file or directory to delete.
   */
  public static void rm(File file) {
<span class="fc" id="L486">    Path p = Check.notNull(file).ok(File::toPath);</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">    if (Files.exists(p)) {</span>
      try {
<span class="fc" id="L489">        rm(p);</span>
<span class="nc" id="L490">      } catch (IOException e) {</span>
<span class="nc" id="L491">        throw ExceptionMethods.uncheck(e);</span>
<span class="fc" id="L492">      }</span>
    }
<span class="fc" id="L494">  }</span>

  private static void rm(Path p) throws IOException {
<span class="fc" id="L497">    Files.walkFileTree(</span>
        p,
<span class="fc" id="L499">        new SimpleFileVisitor&lt;&gt;() {</span>
          @Override
          public FileVisitResult postVisitDirectory(Path dir, IOException exc)
              throws IOException {
<span class="fc" id="L503">            Files.delete(dir);</span>
<span class="fc" id="L504">            return FileVisitResult.CONTINUE;</span>
          }

          @Override
          public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
              throws IOException {
<span class="fc" id="L510">            Files.delete(file);</span>
<span class="fc" id="L511">            return FileVisitResult.CONTINUE;</span>
          }
        });
<span class="fc" id="L514">  }</span>

  private static synchronized File doCreateTempFile(
      Class&lt;?&gt; requester, String relPath, String ext, boolean touch)
      throws IOException {
<span class="fc" id="L519">    String path = uniquePath(requester, relPath, ext);</span>
<span class="fc" id="L520">    File file = new File(path);</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">    if (touch) {</span>
<span class="pc bpc" id="L522" title="1 of 4 branches missed.">      if (!relPath.isEmpty() &amp;&amp; !relPath.equals(File.separator)) {</span>
<span class="fc" id="L523">        File dir = Path.of(tmpDir(), relPath).toFile();</span>
<span class="fc" id="L524">        dir.mkdirs();</span>
      }
<span class="fc" id="L526">      Check.on(IO, file.createNewFile()).is(yes(),</span>
          &quot;Unable to create temp file \&quot;{arg}\&quot;&quot;);
    }
<span class="fc" id="L529">    return file;</span>
  }

  private static synchronized File doCreateTempDir(
      Class&lt;?&gt; requester, String relPath, String ext, boolean touch)
      throws IOException {
<span class="fc" id="L535">    String path = uniquePath(requester, relPath, ext);</span>
<span class="fc" id="L536">    File dir = new File(path);</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">    if (touch) {</span>
<span class="fc" id="L538">      Check.on(IO, dir.mkdirs()).is(yes(), &quot;Unable to create temp dir \&quot;{arg}\&quot;&quot;);</span>
    }
<span class="fc" id="L540">    return dir;</span>
  }

<span class="fc" id="L543">  private static final AtomicLong counter = new AtomicLong();</span>

  private static String uniquePath(Class&lt;?&gt; requester,
      String relativePath,
      String extension) {
<span class="fc" id="L548">    String sep = File.separator;</span>
<span class="fc" id="L549">    relativePath = ensureSuffix(ensurePrefix(relativePath, sep), sep);</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">    if (isEmpty(extension)) {</span>
<span class="fc" id="L551">      extension = EMPTY_STRING;</span>
    } else {
<span class="fc" id="L553">      extension = ensurePrefix(extension, DOT);</span>
    }
<span class="fc" id="L555">    return tmpDir()</span>
        + relativePath
<span class="fc" id="L557">        + requester.getSimpleName()</span>
        + DOT
<span class="fc" id="L559">        + Thread.currentThread().getName()</span>
        + DOT
<span class="fc" id="L561">        + System.currentTimeMillis()</span>
        + DOT
<span class="fc" id="L563">        + lpad(counter.incrementAndGet(), 8, '0')</span>
        + extension;
  }

  private static String tmpDir() {
<span class="fc" id="L568">    return System.getProperty(&quot;java.io.tmpdir&quot;);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>