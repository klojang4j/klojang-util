<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ArrayMethods.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Klojang Check</a> &gt; <a href="index.source.html" class="el_package">org.klojang.util</a> &gt; <span class="el_source">ArrayMethods.java</span></div><h1>ArrayMethods.java</h1><pre class="source lang-java linenums">package org.klojang.util;

import org.klojang.check.Check;
import org.klojang.check.aux.Result;
import org.klojang.util.x.Param;

import java.util.*;
import java.util.function.*;
import java.util.stream.IntStream;

import static java.lang.System.arraycopy;
import static java.util.function.Function.identity;
import static java.util.stream.Collectors.joining;
import static org.klojang.check.CommonChecks.*;
import static org.klojang.util.CollectionMethods.SEPARATOR;
import static org.klojang.util.CollectionMethods.STRINGIFIER;
import static org.klojang.util.InvokeMethods.getArrayElement;
import static org.klojang.util.InvokeMethods.newArray;
import static org.klojang.util.ObjectMethods.ifNull;
import static org.klojang.util.x.Constants.IMPLODE_SEPARATOR;
import static org.klojang.util.x.Param.*;

/**
 * Methods for working with arrays.
 */
public final class ArrayMethods {

<span class="nc" id="L28">  private ArrayMethods() {</span>
<span class="nc" id="L29">    throw new UnsupportedOperationException();</span>
  }

  /**
   * A zero-length Object array.
   */
<span class="fc" id="L35">  public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];</span>

  /**
   * A zero-length String array.
   */
<span class="fc" id="L40">  public static final String[] EMPTY_STRING_ARRAY = new String[0];</span>

  /**
   * A zero-length int array.
   */
<span class="fc" id="L45">  public static final int[] EMPTY_INT_ARRAY = new int[0];</span>

  static final String START_INDEX = &quot;Start index&quot;;
  static final String END_INDEX = &quot;End index&quot;;

<span class="fc" id="L50">  private static final Long MAX_ARR_LEN = (long) Integer.MAX_VALUE;</span>

  /**
   * Appends an element to an array.
   *
   * @param array the array to append the object to
   * @param obj the object to append
   * @param &lt;T&gt; the type of the array elements
   * @return a new array containing the original array plus the extra element
   */
  public static &lt;T&gt; T[] append(T[] array, T obj) {
<span class="fc" id="L61">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L62">    T[] arr = fromTemplate(array, array.length + 1);</span>
<span class="fc" id="L63">    arraycopy(array, 0, arr, 0, array.length);</span>
<span class="fc" id="L64">    arr[array.length] = obj;</span>
<span class="fc" id="L65">    return arr;</span>
  }

  /**
   * Appends multiple elements to an array.
   *
   * @param array the array to append the objects to
   * @param obj0 the 1st object to append
   * @param obj1 the 2nd object to append
   * @param moreObjs more objects to append
   * @param &lt;T&gt; the type of the array elements
   * @return a new array containing the original array plus the extra elements
   */
  @SafeVarargs
  public static &lt;T&gt; T[] append(T[] array, T obj0, T obj1, T... moreObjs) {
<span class="fc" id="L80">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L81">    Check.notNull(moreObjs, Param.MORE_OBJS);</span>
<span class="fc" id="L82">    int sz = array.length + 2 + moreObjs.length;</span>
<span class="fc" id="L83">    T[] arr = fromTemplate(array, sz);</span>
<span class="fc" id="L84">    arraycopy(array, 0, arr, 0, array.length);</span>
<span class="fc" id="L85">    arr[array.length] = obj0;</span>
<span class="fc" id="L86">    arr[array.length + 1] = obj1;</span>
<span class="fc" id="L87">    arraycopy(moreObjs, 0, arr, array.length + 2, moreObjs.length);</span>
<span class="fc" id="L88">    return arr;</span>
  }

  /**
   * Concatenates two arrays.
   *
   * @param arr0 The 1st array to go into the new array
   * @param arr1 The 2nd array to go into the new array
   * @param &lt;T&gt; the type of the array elements
   * @return a new array containing all elements of the specified arrays
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;T&gt; T[] concat(T[] arr0, T[] arr1) {
<span class="nc" id="L101">    return (T[]) concat(arr0, arr1, new Object[0][0]);</span>
  }

  /**
   * Concatenates multiple arrays into a single array.
   *
   * @param arr0 The 1st array to go into the new array
   * @param arr1 The 2nd array to go into the new array
   * @param arr2 The 3rd array to go into the new array
   * @param moreArrays More arrays to concatenate
   * @param &lt;T&gt; the type of the array elements
   * @return a new array containing all elements of the specified arrays
   */
  @SafeVarargs
  public static &lt;T&gt; T[] concat(T[] arr0, T[] arr1, T[] arr2, T[]... moreArrays) {
<span class="fc" id="L116">    Check.notNull(arr0, &quot;arr0&quot;);</span>
<span class="fc" id="L117">    Check.notNull(arr1, &quot;arr1&quot;);</span>
<span class="fc" id="L118">    Check.notNull(arr2, &quot;arr2&quot;);</span>
<span class="fc" id="L119">    Check.notNull(moreArrays, &quot;moreArrays&quot;);</span>
<span class="fc" id="L120">    long x = Arrays.stream(moreArrays).flatMap(Arrays::stream).count();</span>
<span class="fc" id="L121">    x += arr0.length + arr1.length + arr2.length;</span>
<span class="fc" id="L122">    Check.that(x).is(LTE(), MAX_ARR_LEN, &quot;too many elements: ${arg}&quot;);</span>
<span class="fc" id="L123">    T[] all = fromTemplate(arr0, (int) x);</span>
<span class="fc" id="L124">    int i = 0;</span>
<span class="fc" id="L125">    arraycopy(arr0, 0, all, i, arr0.length);</span>
<span class="fc" id="L126">    i += arr0.length;</span>
<span class="fc" id="L127">    arraycopy(arr1, 0, all, i, arr1.length);</span>
<span class="fc" id="L128">    i += arr1.length;</span>
<span class="fc" id="L129">    arraycopy(arr2, 0, all, i, arr2.length);</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">    if (moreArrays.length != 0) {</span>
<span class="fc" id="L131">      i += arr2.length;</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">      for (int j = 0; j &lt; moreArrays.length; ++j) {</span>
<span class="fc" id="L133">        T[] arr = moreArrays[j];</span>
<span class="fc" id="L134">        Check.that(arr).is(notNull(), &quot;array {0} must not be null&quot;, j + 4);</span>
<span class="fc" id="L135">        arraycopy(arr, 0, all, i, arr.length);</span>
<span class="fc" id="L136">        i += arr.length;</span>
      }
    }
<span class="fc" id="L139">    return all;</span>
  }

  /**
   * Returns {@code true} if the specified array contains the specified value.
   *
   * @param value the value to search for
   * @param array the array to search
   * @return whether the array contains the value
   * @see #indexOf(int[], int)
   */
  public static boolean isElementOf(int value, int[] array) {
<span class="fc" id="L151">    return indexOf(array, value).isPresent();</span>
  }

  /**
   * Returns {@code true} if the specified array contains the specified value.
   *
   * @param value the value to search for
   * @param array the array to search
   * @param &lt;T&gt; the type of the array elements
   * @return whether the array contains the value
   * @see #indexOf(Object[], Object)
   */
  public static &lt;T&gt; boolean isElementOf(T value, T[] array) {
<span class="fc bfc" id="L164" title="All 2 branches covered.">    return indexOf(array, value) != -1;</span>
  }

  /**
   * Returns {@code true} if the specified array contains the specified reference.
   *
   * @param reference the reference to search for
   * @param references the array to search
   * @return whether the array contains the reference
   * @see #refIndexOf(Object[], Object)
   */
  public static boolean isOneOf(Object reference, Object... references) {
<span class="nc bnc" id="L176" title="All 2 branches missed.">    return refIndexOf(references, reference) != -1;</span>
  }

  /**
   * Returns an {@link OptionalInt} containing the array index of the first
   * occurrence of the specified value within the specified array. Returns an empty
   * {@link OptionalInt} if the array does not contain the value.
   *
   * @param array the array to search
   * @param value the value to search for
   * @return an {@link OptionalInt} containing the array index of the value
   */
  public static OptionalInt indexOf(int[] array, int value) {
<span class="fc" id="L189">    Check.notNull(array, ARRAY);</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">    for (int x = 0; x &lt; array.length; ++x) {</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">      if (array[x] == value) {</span>
<span class="fc" id="L192">        return OptionalInt.of(x);</span>
      }
    }
<span class="fc" id="L195">    return OptionalInt.empty();</span>
  }

  /**
   * Returns an {@link OptionalInt} containing the array index of the last occurrence
   * of the specified value within the specified array. Returns an empty
   * {@link OptionalInt} if the array does not contain the value.
   *
   * @param array the array to search
   * @param value the value to search for
   * @return an {@link OptionalInt} containing the array index of the value
   */
  public static OptionalInt lastIndexOf(int[] array, int value) {
<span class="fc" id="L208">    Check.notNull(array, ARRAY);</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">    for (int x = array.length - 1; x &gt;= 0; --x) {</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">      if (array[x] == value) {</span>
<span class="fc" id="L211">        return OptionalInt.of(x);</span>
      }
    }
<span class="fc" id="L214">    return OptionalInt.empty();</span>
  }

  /**
   * Returns the array index of the first occurrence of the specified value within
   * the specified array. Returns -1 if the array does not contain the value.
   * Searching for null is allowed.
   *
   * @param &lt;T&gt; the type of the elements within the array
   * @param array the array to search
   * @param value the value to search for (may be null)
   * @return the array index of the value
   */
  public static &lt;T&gt; int indexOf(T[] array, T value) {
<span class="fc" id="L228">    Check.notNull(array, ARRAY);</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">    if (value == null) {</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">      for (int x = 0; x &lt; array.length; ++x) {</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">        if (array[x] == null) {</span>
<span class="fc" id="L232">          return x;</span>
        }
      }
    } else {
<span class="fc bfc" id="L236" title="All 2 branches covered.">      for (int x = 0; x &lt; array.length; ++x) {</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">        if (value.equals(array[x])) {</span>
<span class="fc" id="L238">          return x;</span>
        }
      }
    }
<span class="fc" id="L242">    return -1;</span>
  }

  /**
   * Returns the array index of the last occurrence of the specified value within the
   * specified array. Returns -1 if the array does not contain the value. Searching
   * for null is allowed.
   *
   * @param &lt;T&gt; the type of the elements within the array
   * @param array the array to search
   * @param value the value to search for (may be null)
   * @return the array index of the value
   */
  public static &lt;T&gt; int lastIndexOf(T[] array, T value) {
<span class="fc" id="L256">    Check.notNull(array, ARRAY);</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">    if (value == null) {</span>
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">      for (int x = array.length - 1; x &gt;= 0; --x) {</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">        if (array[x] == null) {</span>
<span class="fc" id="L260">          return x;</span>
        }
      }
    } else {
<span class="fc bfc" id="L264" title="All 2 branches covered.">      for (int x = array.length - 1; x &gt;= 0; --x) {</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">        if (value.equals(array[x])) {</span>
<span class="fc" id="L266">          return x;</span>
        }
      }
    }
<span class="fc" id="L270">    return -1;</span>
  }

  /**
   * Returns the array index of the first occurrence of the specified object, using
   * reference comparisons to identify the object. Returns -1 if the array does not
   * contain the specified reference. Searching for null is
   * &lt;i&gt;not&lt;/i&gt; allowed.
   *
   * @param array the array to search
   * @param reference The reference to search for (must not be null)
   * @return the array index of the reference
   */
  public static int refIndexOf(Object[] array, Object reference) {
<span class="fc" id="L284">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L285">    Check.notNull(reference, &quot;reference&quot;);</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">    for (int i = 0; i &lt; array.length; ++i) {</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">      if (array[i] == reference) {</span>
<span class="fc" id="L288">        return i;</span>
      }
    }
<span class="fc" id="L291">    return -1;</span>
  }

  /**
   * Returns the array index of the last occurrence of the specified object, using
   * reference comparisons to identify the object. Returns -1 if the array does not
   * contain the specified reference. Searching for null is &lt;i&gt;not&lt;/i&gt; allowed.
   *
   * @param array the array to search
   * @param reference The reference to search for (must not be null)
   * @return the array index of the reference
   */
  public static int refLastIndexOf(Object[] array, Object reference) {
<span class="fc" id="L304">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L305">    Check.notNull(reference, &quot;reference&quot;);</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">    for (int i = array.length - 1; i &gt;= 0; --i) {</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">      if (array[i] == reference) {</span>
<span class="fc" id="L308">        return i;</span>
      }
    }
<span class="nc" id="L311">    return -1;</span>
  }

  /**
   * Returns the first array element that passes the specified test, or
   * {@link Result#notAvailable()} if no element passed the test.
   *
   * @param array the array
   * @param test the test
   * @param &lt;T&gt; the type of the array elements
   * @return the first array element that passes the specified test, or
   *     {@link Result#notAvailable()} if no element passed the test.
   */
  public static &lt;T&gt; Result&lt;T&gt; find(T[] array, Predicate&lt;T&gt; test) {
<span class="fc" id="L325">    return find(array, test, identity());</span>
  }

  /**
   * Returns a {@link Result} containing a property of the first array element that
   * passes the specified test, or {@link Result#notAvailable()} if no element passed
   * the test.
   *
   * &lt;blockquote&gt;&lt;pre&gt;{@code
   * Person[] persons = getPersons();
   * find(persons, p -&gt; p.age() &lt; 15, Person::firstName).ifAvailable(
   *    name -&gt; System.out.printf(&quot;And the winner is ..... %s!!!%n, name);
   * );
   * }&lt;/pre&gt;&lt;/blockquote&gt;
   *
   * @param array the array
   * @param test the test
   * @param property a function that extracts some value from thr array element
   * @param &lt;T&gt; the type of the array elements
   * @param &lt;R&gt; the type of the value extracted from the array element
   * @return the {@code Result} containing the value extracted from the first array
   *     element that passed the specified test, or {@code null} if no element passed
   *     the test
   */
  public static &lt;T, R&gt; Result&lt;R&gt; find(T[] array,
      Predicate&lt;T&gt; test,
      Function&lt;T, R&gt; property) {
<span class="fc" id="L352">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L353">    Check.notNull(test, Param.TEST);</span>
<span class="fc" id="L354">    Check.notNull(property, Param.PROPERTY);</span>
<span class="fc" id="L355">    return Arrays.stream(array)</span>
<span class="fc" id="L356">        .filter(test)</span>
<span class="fc" id="L357">        .map(property)</span>
<span class="fc" id="L358">        .map(Result::of)</span>
<span class="fc" id="L359">        .findFirst()</span>
<span class="fc" id="L360">        .orElse(Result.notAvailable());</span>
  }

  /**
   * Returns the first array element that passes the specified test, or an empty
   * {@code OptionalInt} if no element passed the test.
   *
   * @param array the array
   * @param test the test
   * @return the first array element that passes the specified test, or an empty
   *     {@code OptionalInt} if no element passed the test
   */
  public static OptionalInt find(int[] array, IntPredicate test) {
<span class="fc" id="L373">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L374">    Check.notNull(test, TEST);</span>
<span class="fc" id="L375">    return Arrays.stream(array)</span>
<span class="fc" id="L376">        .filter(test)</span>
<span class="fc" id="L377">        .mapToObj(OptionalInt::of)</span>
<span class="fc" id="L378">        .findFirst()</span>
<span class="fc" id="L379">        .orElse(OptionalInt.empty());</span>
  }

  /**
   * Reverses the order of the elements in the specified array.
   *
   * @param array the array
   * @param &lt;T&gt; the type of the array elements
   * @return the input array
   */
  public static &lt;T&gt; T[] reverse(T[] array) {
<span class="fc" id="L390">    return doReverse(array, 0, array.length);</span>
  }

  /**
   * Reverses the order of the elements in the specified array segment.
   *
   * @param array the array
   * @param from the start index (inclusive) of the array segment
   * @param to the end index (exclusive) of the array segment
   * @param &lt;T&gt; the type of the array elements
   * @return the input array
   */
  public static &lt;T&gt; T[] reverse(T[] array, int from, int to) {
<span class="fc" id="L403">    Check.fromTo(array, from, to);</span>
<span class="fc" id="L404">    return doReverse(array, from, to);</span>
  }

  private static &lt;T&gt; T[] doReverse(T[] array, int from, int to) {
<span class="fc bfc" id="L408" title="All 2 branches covered.">    for (int i = 0, j = to - 1; i &lt; (to - from) / 2; ++i, --j) {</span>
<span class="fc" id="L409">      T tmp = array[from + i];</span>
<span class="fc" id="L410">      array[from + i] = array[j];</span>
<span class="fc" id="L411">      array[j] = tmp;</span>
    }
<span class="fc" id="L413">    return array;</span>
  }

  /**
   * Reverses the order of the elements in the specified array.
   *
   * @param array the array
   * @return the input array
   */
  public static int[] reverse(int[] array) {
<span class="fc" id="L423">    return doReverse(array, 0, array.length);</span>
  }

  /**
   * Reverses the order of the elements in the specified array segment
   *
   * @param array the array
   * @param from the start index (inclusive) of the array segment
   * @param to the end index (exclusive) of the array segment
   * @return the input array
   */
  public static int[] reverse(int[] array, int from, int to) {
<span class="fc" id="L435">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L436">    Check.fromTo(array.length, from, to);</span>
<span class="fc" id="L437">    return doReverse(array, from, to);</span>
  }

  private static int[] doReverse(int[] array, int from, int to) {
<span class="fc bfc" id="L441" title="All 2 branches covered.">    for (int i = 0, j = to - 1; i &lt; (to - from) / 2; ++i, --j) {</span>
<span class="fc" id="L442">      int tmp = array[from + i];</span>
<span class="fc" id="L443">      array[from + i] = array[j];</span>
<span class="fc" id="L444">      array[j] = tmp;</span>
    }
<span class="fc" id="L446">    return array;</span>
  }

<span class="fc" id="L449">  private static final Map&lt;Class&lt;?&gt;, ToIntFunction&lt;Object&gt;&gt; hashCoders =</span>
<span class="fc" id="L450">      Map.of(</span>
<span class="fc" id="L451">          int[].class, obj -&gt; Arrays.hashCode((int[]) obj),</span>
<span class="nc" id="L452">          long[].class, obj -&gt; Arrays.hashCode((long[]) obj),</span>
<span class="nc" id="L453">          double[].class, obj -&gt; Arrays.hashCode((double[]) obj),</span>
<span class="nc" id="L454">          float[].class, obj -&gt; Arrays.hashCode((float[]) obj),</span>
<span class="nc" id="L455">          char[].class, obj -&gt; Arrays.hashCode((char[]) obj),</span>
<span class="nc" id="L456">          short[].class, obj -&gt; Arrays.hashCode((short[]) obj),</span>
<span class="nc" id="L457">          byte[].class, obj -&gt; Arrays.hashCode((byte[]) obj));</span>

  /**
   * Returns the hash code of an array. Allows you to retrieve the hash code of an
   * array object even if you don't know its exact type. An
   * {@link IllegalArgumentException} is thrown if the argument is not an array.
   *
   * @param array the array
   * @return Its hash code
   */
  public static int hashCode(Object array) {
<span class="fc" id="L468">    Check.notNull(array).is(array());</span>
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">    if (array instanceof Object[] objs) {</span>
<span class="nc" id="L470">      return Arrays.hashCode(objs);</span>
    }
<span class="fc" id="L472">    return hashCoders.get(array.getClass()).applyAsInt(array);</span>
  }

  /**
   * Returns the deep hash code of an array. Allow you to retrieve the deep hash code
   * of an array object even if you don't know its exact type. An
   * {@link IllegalArgumentException} is thrown if the argument is not an array.
   *
   * @param array the array
   * @return Its deep hash code
   */
  public static int deepHashCode(Object array) {
<span class="nc" id="L484">    Check.notNull(array).is(array());</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">    if (array instanceof Object[] objs) {</span>
<span class="nc" id="L486">      return Arrays.deepHashCode(objs);</span>
    }
<span class="nc" id="L488">    return hashCoders.get(array.getClass()).applyAsInt(array);</span>
  }

  /**
   * PHP-style implode method, concatenating the array elements using &quot;, &quot;
   * (comma-space) as separator. Optimized for {@code int[]} arrays.
   *
   * @param array the array to implode
   * @return a concatenation of the elements in the array.
   */
  public static String implodeInts(int[] array) {
<span class="fc" id="L499">    return implodeInts(array, IMPLODE_SEPARATOR);</span>
  }

  /**
   * PHP-style implode method, concatenating the array elements using the specified
   * separator. Optimized for {@code int[]} arrays.
   *
   * @param array the array to implode
   * @param separator the string used to separate the elements
   * @return a concatenation of the elements in the array.
   */
  public static String implodeInts(int[] array, String separator) {
<span class="fc" id="L511">    return implodeInts(array, separator, -1);</span>
  }

  /**
   * PHP-style implode method, concatenating at most {@code limit} array elements
   * using &quot;, &quot; (comma-space) as separator.
   *
   * @param array the array to implode
   * @param limit The maximum number of elements to collect. The specified number
   *     will be clamped to {@code array.length} (i.e. it's OK to specify a number
   *     greater than {@code array.length}). You can specify -1 as a shorthand for
   *     {@code array.length}.
   * @return a concatenation of the elements in the array.
   */
  public static String implodeInts(int[] array, int limit) {
<span class="fc" id="L526">    return implodeInts(array, IMPLODE_SEPARATOR, limit);</span>
  }

  /**
   * PHP-style implode method, concatenating at most {@code limit} array elements
   * using &quot;, &quot; (comma-space) as separator.
   *
   * @param array the array to implode
   * @param stringifier A {@code Function} that converts the array elements to
   *     strings
   * @return a concatenation of the elements in the array.
   */
  public static String implodeInts(int[] array, IntFunction&lt;String&gt; stringifier) {
<span class="fc" id="L539">    return implodeInts(array, stringifier, IMPLODE_SEPARATOR, 0, -1);</span>
  }

  /**
   * PHP-style implode method, concatenating at most {@code limit} array elements
   * using the specified separator.
   *
   * @param array the array to implode
   * @param separator the string used to separate the elements
   * @param limit The maximum number of elements to collect. The specified number
   *     will be clamped to {@code array.length} (i.e. it's OK to specify a number
   *     greater than {@code array.length}). You can specify -1 as a shorthand for
   *     {@code array.length}.
   * @return a concatenation of the elements in the array.
   */
  public static String implodeInts(int[] array, String separator, int limit) {
<span class="fc" id="L555">    return implodeInts(array, String::valueOf, separator, 0, limit);</span>
  }

  /**
   * PHP-style implode method, optimized for {@code int[]} arrays.
   *
   * @param array the array to implode
   * @param stringifier A {@code Function} that converts the array elements to
   *     strings
   * @param separator the string used to separate the elements
   * @param from The index of the element to begin the concatenation with
   *     (inclusive)
   * @param to The index of the element to end the concatenation with
   *     (exclusive). The specified number will be clamped to {@code array.length}
   *     (i.e. it's OK to specify a number greater than {@code array.length}). You
   *     can specify -1 as a shorthand for {@code array.length}.
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, Function, String, int, int)
   */
  public static String implodeInts(int[] array,
      IntFunction&lt;String&gt; stringifier,
      String separator,
      int from,
      int to) {
<span class="fc" id="L579">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L580">    Check.notNull(separator, SEPARATOR);</span>
<span class="fc" id="L581">    Check.that(from, FROM_INDEX).is(gte(), 0).is(lte(), array.length);</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">    int x = to == -1 ? array.length : Math.min(to, array.length);</span>
<span class="fc" id="L583">    Check.that(x, TO_INDEX).is(gte(), from);</span>
<span class="fc" id="L584">    return Arrays.stream(array, from, x)</span>
<span class="fc" id="L585">        .mapToObj(stringifier)</span>
<span class="fc" id="L586">        .collect(joining(separator));</span>
  }

  /**
   * PHP-style implode method, concatenating the array elements using &quot;, &quot;
   * (comma-space) as separator. This method is primarily meant to implode primitive
   * arrays, but you &lt;i&gt;can&lt;/i&gt; use it to implode any type of array. An
   * {@link IllegalArgumentException} is thrown if {@code array} is not an array.
   *
   * @param array the array to implode
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, String)
   */
  public static String implodeAny(Object array) {
<span class="fc" id="L600">    return implodeAny(array, Objects::toString, IMPLODE_SEPARATOR, 0, -1);</span>
  }

  /**
   * PHP-style implode method, concatenating the array elements using the specified
   * separator. This method is primarily meant to implode primitive arrays, but you
   * &lt;i&gt;can&lt;/i&gt; use it to implode any type of array. An {@link
   * IllegalArgumentException} is thrown if {@code array} is not an array.
   *
   * @param array the array to implode
   * @param separator the string used to separate the elements
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, String)
   */
  public static String implodeAny(Object array, String separator) {
<span class="fc" id="L615">    return implodeAny(array, separator, -1);</span>
  }

  /**
   * PHP-style implode method, concatenating the array elements using &quot;, &quot;
   * (comma-space) as separator. This method is primarily meant to implode primitive
   * arrays, but you &lt;i&gt;can&lt;/i&gt; use it to implode any type of array. An
   * {@link IllegalArgumentException} is thrown if {@code array} is not an array.
   *
   * @param array the array to implode
   * @param stringifier A {@code Function} that converts the array elements to
   *     strings
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, String)
   */
  public static String implodeAny(Object array,
      Function&lt;Object, String&gt; stringifier) {
<span class="fc" id="L632">    return implodeAny(array, stringifier, IMPLODE_SEPARATOR, 0, -1);</span>
  }

  /**
   * PHP-style implode method, concatenating at most {@code limit} array elements
   * using &quot;, &quot; (comma-space) as separator. This method is primarily meant to implode
   * primitive arrays, but you &lt;i&gt;can&lt;/i&gt; use it to implode any type of array. An
   * {@link IllegalArgumentException} is thrown if {@code array} is not an array.
   *
   * @param array the array to implode
   * @param limit The maximum number of elements to collect. The specified number
   *     will be clamped to {@code array.length} (i.e. it's OK to specify a number
   *     greater than {@code array.length}). You can specify -1 as a shorthand for
   *     {@code array.length}.
   * @return a concatenation of the elements in the array.
   */
  public static String implodeAny(Object array, int limit) {
<span class="fc" id="L649">    return implodeAny(array, IMPLODE_SEPARATOR, limit);</span>
  }

  /**
   * PHP-style implode method, concatenating at most {@code limit} array elements
   * using the specified separator. This method is primarily meant to implode
   * primitive arrays, but you &lt;i&gt;can&lt;/i&gt; use it to implode any type of array. An
   * {@link IllegalArgumentException} is thrown if {@code array} is not an array.
   *
   * @param array the array to implode
   * @param separator the string used to separate the elements
   * @param limit The maximum number of elements to collect. The specified number
   *     will be clamped to {@code array.length} (i.e. it's OK to specify a number
   *     greater than {@code array.length}). You can specify -1 as a shorthand for
   *     {@code array.length}.
   * @return a concatenation of the elements in the array.
   */
  public static String implodeAny(Object array, String separator, int limit) {
<span class="fc" id="L667">    return implodeAny(array, Objects::toString, separator, 0, limit);</span>
  }

  /**
   * PHP-style implode method. This method is primarily meant to implode primitive
   * arrays, but you &lt;i&gt;can&lt;/i&gt; use it to implode any type of array. An
   * {@link IllegalArgumentException} is thrown if {@code array} is not an array.
   *
   * @param array the array to implode
   * @param stringifier A {@code Function} that converts the array elements to
   *     strings
   * @param separator the string used to separate the elements
   * @param from The index of the element to begin the concatenation with
   *     (inclusive)
   * @param to The index of the element to end the concatenation with
   *     (exclusive). The specified number will be clamped to {@code array.length}
   *     (i.e. it's OK to specify a number greater than {@code array.length}). You
   *     can specify -1 as a shorthand for {@code array.length}.
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, Function, String, int, int)
   */
  public static String implodeAny(Object array,
      Function&lt;Object, String&gt; stringifier,
      String separator,
      int from,
      int to) {
<span class="fc" id="L693">    int len = Check.notNull(array, ARRAY)</span>
<span class="fc" id="L694">        .is(array())</span>
<span class="fc" id="L695">        .ok(InvokeMethods::getArrayLength);</span>
<span class="fc" id="L696">    Check.notNull(stringifier, STRINGIFIER);</span>
<span class="fc" id="L697">    Check.notNull(separator, SEPARATOR);</span>
<span class="fc" id="L698">    Check.that(from, FROM_INDEX).is(gte(), 0).is(lte(), len);</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">    int x = to == -1 ? len : Math.min(to, len);</span>
<span class="fc" id="L700">    Check.that(x, TO_INDEX).is(gte(), from);</span>
<span class="fc" id="L701">    return IntStream.range(from, x)</span>
<span class="fc" id="L702">        .mapToObj(i -&gt; getArrayElement(array, i))</span>
<span class="fc" id="L703">        .map(stringifier)</span>
<span class="fc" id="L704">        .collect(joining(separator));</span>
  }

  /**
   * PHP-style implode method, concatenating the array elements using &quot;, &quot;
   * (comma-space) as separator.
   *
   * @param array the collection to implode
   * @param &lt;T&gt; the type of the array elements
   * @return a concatenation of the elements in the collection.
   * @see CollectionMethods#implode(Collection)
   */
  public static &lt;T&gt; String implode(T[] array) {
<span class="fc" id="L717">    return implode(array, IMPLODE_SEPARATOR);</span>
  }

  /**
   * PHP-style implode method, concatenating the array elements using the specified
   * separator.
   *
   * @param array the array to implode
   * @param separator the string used to separate the elements
   * @param &lt;T&gt; the type of the array elements
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, String)
   */
  public static &lt;T&gt; String implode(T[] array, String separator) {
<span class="fc" id="L731">    Check.notNull(array);</span>
<span class="fc" id="L732">    return implode(array, Objects::toString, separator, 0, -1);</span>
  }

  /**
   * PHP-style implode method, concatenating at most {@code limit} array elements
   * using &quot;, &quot; (comma+space) as separator.
   *
   * @param array the array to implode
   * @param limit The maximum number of elements to collect. The specified number
   *     will be clamped to {@code array.length} (i.e. it's OK to specify a number
   *     greater than {@code array.length}). You can specify -1 as a shorthand for
   *     {@code array.length}.
   * @param &lt;T&gt; the type of the array elements
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, int)
   */
  public static &lt;T&gt; String implode(T[] array, int limit) {
<span class="fc" id="L749">    return implode(array, IMPLODE_SEPARATOR, limit);</span>
  }

  /**
   * PHP-style implode method, concatenating at most {@code limit} array elements
   * using &quot;, &quot; (comma+space) as separator.
   *
   * @param array the array to implode
   * @param stringifier A {@code Function} that converts the array elements to
   *     strings
   * @param &lt;T&gt; the type of the array elements
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, int)
   */
  public static &lt;T&gt; String implode(T[] array, Function&lt;T, String&gt; stringifier) {
<span class="fc" id="L764">    return implode(array, stringifier, IMPLODE_SEPARATOR, 0, -1);</span>
  }

  /**
   * PHP-style implode method, concatenating at most {@code limit} array elements
   * using the specified separator.
   *
   * @param array the array to implode
   * @param separator the string used to separate the elements
   * @param limit The maximum number of elements to collect. The specified number
   *     will be clamped to {@code array.length} (i.e. it's OK to specify a number
   *     greater than {@code array.length}). You can specify -1 as a shorthand for
   *     {@code array.length}.
   * @param &lt;T&gt; the type of the array elements
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, String, int)
   */
  public static &lt;T&gt; String implode(T[] array, String separator, int limit) {
<span class="fc" id="L782">    return implode(array, Objects::toString, separator, 0, limit);</span>
  }

  /**
   * PHP-style implode method.
   *
   * @param array the array to implode
   * @param stringifier A {@code Function} that converts the array elements to
   *     strings
   * @param separator the string used to separate the elements
   * @param from The index of the element to begin the concatenation with
   *     (inclusive)
   * @param to The index of the element to end the concatenation with
   *     (exclusive). The specified number will be clamped to {@code array.length}
   *     (i.e. it's OK to specify a number greater than {@code array.length}). You
   *     can specify -1 as a shorthand for {@code array.length}.
   * @param &lt;T&gt; the type of the array elements
   * @return a concatenation of the elements in the array.
   * @see CollectionMethods#implode(Collection, Function, String, int, int)
   */
  public static &lt;T&gt; String implode(T[] array,
      Function&lt;T, String&gt; stringifier,
      String separator,
      int from,
      int to) {
<span class="fc" id="L807">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L808">    Check.notNull(stringifier, STRINGIFIER);</span>
<span class="fc" id="L809">    Check.notNull(separator, SEPARATOR);</span>
<span class="fc" id="L810">    Check.that(from, FROM_INDEX).is(gte(), 0).is(lte(), array.length);</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">    int x = to == -1 ? array.length : Math.min(to, array.length);</span>
<span class="fc" id="L812">    Check.that(x, TO_INDEX).is(gte(), from);</span>
<span class="fc" id="L813">    return Arrays.stream(array, from, x)</span>
<span class="fc" id="L814">        .map(stringifier)</span>
<span class="fc" id="L815">        .collect(joining(separator));</span>
  }

  /**
   * Simply returns the specified array, but allows for leaner code when statically
   * imported.
   *
   * @param objs the array
   * @param &lt;T&gt; the type of the objects to pack
   * @return the same array
   */
  @SafeVarargs
  public static &lt;T&gt; T[] pack(T... objs) {
<span class="fc" id="L828">    return Check.notNull(objs).ok();</span>
  }

  /**
   * Simply returns the specified array, but allows for leaner code when statically
   * imported.
   *
   * @param ints the array
   * @return the same array
   */
  public static int[] ints(int... ints) {
<span class="fc" id="L839">    return Check.notNull(ints).ok();</span>
  }

  /**
   * Simply returns the specified array, but allows for leaner code when statically
   * imported.
   *
   * @param chars the array
   * @return the same array
   */
  public static char[] chars(char... chars) {
<span class="fc" id="L850">    return Check.notNull(chars).ok();</span>
  }

  /**
   * Simply returns the specified array, but allows for leaner code when statically
   * imported.
   *
   * @param doubles the array
   * @return the same array
   */
  public static double[] doubles(double... doubles) {
<span class="fc" id="L861">    return Check.notNull(doubles).ok();</span>
  }

  /**
   * Simply returns the specified array, but allows for leaner code when statically
   * imported.
   *
   * @param longs the array
   * @return the same array
   */
  public static long[] longs(long... longs) {
<span class="fc" id="L872">    return Check.notNull(longs).ok();</span>
  }

  /**
   * Simply returns the specified array, but allows for leaner code when statically
   * imported.
   *
   * @param floats The array
   * @return the same array
   */
  public static float[] floats(float... floats) {
<span class="fc" id="L883">    return Check.notNull(floats).ok();</span>
  }

  /**
   * Prefixes the specified object to the specified array.
   *
   * @param array the array to be prefixed
   * @param obj the object to prefix
   * @param &lt;T&gt; the type of the array elements and the object to be prefixed
   * @return a new array containing the specified object and the elements of the
   *     specified array
   */
  public static &lt;T&gt; T[] prefix(T[] array, T obj) {
<span class="fc" id="L896">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L897">    T[] res = fromTemplate(array, array.length + 1);</span>
<span class="fc" id="L898">    res[0] = obj;</span>
<span class="fc" id="L899">    arraycopy(array, 0, res, 1, array.length);</span>
<span class="fc" id="L900">    return res;</span>
  }

  /**
   * Prefixes the specified object to the specified array.
   *
   * @param array the array to be prefixed
   * @param obj0 the 1st object to prefix
   * @param obj1 the 2nd object to prefix
   * @param moreObjs more objects to prefix
   * @param &lt;T&gt; the type of the array elements and the object to be prefixed
   * @return a new array containing the specified objects and the elements of the
   *     specified array
   */
  @SafeVarargs
  public static &lt;T&gt; T[] prefix(T[] array, T obj0, T obj1, T... moreObjs) {
<span class="fc" id="L916">    Check.notNull(array, ARRAY);</span>
<span class="fc" id="L917">    Check.notNull(moreObjs, MORE_OBJS);</span>
<span class="fc" id="L918">    int sz = array.length + 2 + moreObjs.length;</span>
<span class="fc" id="L919">    T[] res = fromTemplate(array, sz);</span>
<span class="fc" id="L920">    res[0] = obj0;</span>
<span class="fc" id="L921">    res[1] = obj1;</span>
<span class="fc" id="L922">    arraycopy(moreObjs, 0, res, 2, moreObjs.length);</span>
<span class="fc" id="L923">    arraycopy(array, 0, res, 2 + moreObjs.length, array.length);</span>
<span class="fc" id="L924">    return res;</span>
  }

  /**
   * Converts an {@code int} array to a {@code List&lt;Integer&gt;}.
   *
   * @param values the array elements.
   * @return a {@code List} containing the same elements in the same order
   */
  public static List&lt;Integer&gt; asList(int[] values) {
<span class="fc" id="L934">    return Arrays.asList(box(values));</span>
  }

  /**
   * Converts a {@code float} array to a {@code List&lt;Float&gt;}.
   *
   * @param values the array elements.
   * @return a {@code List} containing the same elements in the same order
   */
  public static List&lt;Float&gt; asList(float[] values) {
<span class="fc" id="L944">    return Arrays.asList(box(values));</span>
  }

  /**
   * Converts a {@code double} array to a {@code List&lt;Double&gt;}.
   *
   * @param values the array elements.
   * @return a {@code List} containing the same elements in the same order
   */
  public static List&lt;Double&gt; asList(double[] values) {
<span class="fc" id="L954">    return Arrays.asList(box(values));</span>
  }

  /**
   * Converts a {@code long} array to a {@code List&lt;Long&gt;}.
   *
   * @param values the array elements.
   * @return a {@code List} containing the same elements in the same order
   */
  public static List&lt;Long&gt; asList(long[] values) {
<span class="fc" id="L964">    return Arrays.asList(box(values));</span>
  }

  /**
   * Converts a {@code short} array to a {@code List&lt;Short&gt;}.
   *
   * @param values the array elements.
   * @return a {@code List} containing the same elements in the same order
   */
  public static List&lt;Short&gt; asList(short[] values) {
<span class="fc" id="L974">    return Arrays.asList(box(values));</span>
  }

  /**
   * Converts a {@code byte} array to a {@code List&lt;Byte&gt;}.
   *
   * @param values the array elements.
   * @return a {@code List} containing the same elements in the same order
   */
  public static List&lt;Byte&gt; asList(byte[] values) {
<span class="fc" id="L984">    return Arrays.asList(box(values));</span>
  }

  /**
   * Converts a {@code char} array to a {@code List&lt;Character&gt;}.
   *
   * @param values the array elements.
   * @return a {@code List} containing the same elements in the same order
   */
  public static List&lt;Character&gt; asList(char[] values) {
<span class="fc" id="L994">    return Arrays.asList(box(values));</span>
  }

  /**
   * Converts a {@code boolean} array to a {@code List&lt;Boolean&gt;}.
   *
   * @param values the array elements.
   * @return a {@code List} containing the same elements in the same order
   */
  public static List&lt;Boolean&gt; asList(boolean[] values) {
<span class="fc" id="L1004">    return Arrays.asList(box(values));</span>
  }

  /**
   * Converts an {@code Integer} array to an {@code int} array.
   *
   * @param values the {@code Integer} array
   * @param dfault The {@code int} value to convert {@code null} elements in the
   *     source array to
   * @return the {@code int} array
   */
  public static int[] unbox(Integer[] values, int dfault) {
<span class="fc" id="L1016">    Check.notNull(values);</span>
<span class="fc" id="L1017">    return Arrays.stream(values).mapToInt(i -&gt; ifNull(i, dfault)).toArray();</span>
  }

  /**
   * Converts an {@code Integer} array to an {@code int} array. {@code null} elements
   * in the source array are converted to 0 (zero).
   *
   * @param values the {@code Integer} array
   * @return the {@code int} array
   */
  public static int[] unbox(Integer[] values) {
<span class="fc" id="L1028">    return unbox(values, 0);</span>
  }

  /**
   * Converts an {@code int} array to an {@code Integer} array.
   *
   * @param values the {@code int} array
   * @return the {@code Integer} array
   */
  public static Integer[] box(int[] values) {
<span class="fc" id="L1038">    return Check.notNull(values).ok(Arrays::stream).boxed().toArray(Integer[]::new);</span>
  }

  /**
   * Converts a {@code double} array to a {@code Double} array.
   *
   * @param values the {@code double} array
   * @return the {@code Double} array
   */
  public static Double[] box(double[] values) {
<span class="fc" id="L1048">    return Check.notNull(values).ok(Arrays::stream).boxed().toArray(Double[]::new);</span>
  }

  /**
   * Converts a {@code long} array to a {@code Long} array.
   *
   * @param values the {@code long} array
   * @return the {@code Long} array
   */
  public static Long[] box(long[] values) {
<span class="fc" id="L1058">    return Check.notNull(values).ok(Arrays::stream).boxed().toArray(Long[]::new);</span>
  }

  /**
   * Converts a {@code float} array to a {@code Float} array.
   *
   * @param values the {@code float} array
   * @return the {@code Float} array
   */
  public static Float[] box(float[] values) {
<span class="fc" id="L1068">    var res = new Float[Check.notNull(values).ok().length];</span>
<span class="fc bfc" id="L1069" title="All 2 branches covered.">    for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="fc" id="L1070">      res[i] = values[i];</span>
    }
<span class="fc" id="L1072">    return res;</span>
  }

  /**
   * Converts a {@code short} array to a {@code Short} array.
   *
   * @param values the {@code short} array
   * @return the {@code Short} array
   */
  public static Short[] box(short[] values) {
<span class="fc" id="L1082">    var res = new Short[Check.notNull(values).ok().length];</span>
<span class="fc bfc" id="L1083" title="All 2 branches covered.">    for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="fc" id="L1084">      res[i] = values[i];</span>
    }
<span class="fc" id="L1086">    return res;</span>
  }

  /**
   * Converts a {@code byte} array to a {@code Byte} array.
   *
   * @param values the {@code byte} array
   * @return the {@code Byte} array
   */
  public static Byte[] box(byte[] values) {
<span class="fc" id="L1096">    var res = new Byte[Check.notNull(values).ok().length];</span>
<span class="fc bfc" id="L1097" title="All 2 branches covered.">    for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="fc" id="L1098">      res[i] = values[i];</span>
    }
<span class="fc" id="L1100">    return res;</span>
  }

  /**
   * Converts a {@code char} array to a {@code Character} array.
   *
   * @param values the {@code char} array
   * @return the {@code Character} array
   */
  public static Character[] box(char[] values) {
<span class="fc" id="L1110">    var res = new Character[Check.notNull(values).ok().length];</span>
<span class="fc bfc" id="L1111" title="All 2 branches covered.">    for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="fc" id="L1112">      res[i] = values[i];</span>
    }
<span class="fc" id="L1114">    return res;</span>
  }

  /**
   * Converts a {@code boolean} array to a {@code Boolean} array.
   *
   * @param values the {@code boolean} array
   * @return the {@code Boolean} array
   */
  public static Boolean[] box(boolean[] values) {
<span class="fc" id="L1124">    var res = new Boolean[Check.notNull(values).ok().length];</span>
<span class="fc bfc" id="L1125" title="All 2 branches covered.">    for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="fc" id="L1126">      res[i] = values[i];</span>
    }
<span class="fc" id="L1128">    return res;</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  private static &lt;T&gt; T[] fromTemplate(T[] template, int length) {
<span class="fc" id="L1133">    return (T[]) newArray(template.getClass(), length);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>