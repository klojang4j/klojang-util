<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PathWalker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Klojang Check</a> &gt; <a href="index.source.html" class="el_package">org.klojang.util.path</a> &gt; <span class="el_source">PathWalker.java</span></div><h1>PathWalker.java</h1><pre class="source lang-java linenums">package org.klojang.util.path;

import static org.klojang.check.CommonChecks.*;
import static org.klojang.check.CommonProperties.length;

import java.util.Arrays;
import java.util.List;
import java.util.Map;

import org.klojang.check.Check;
import org.klojang.util.path.KeyDeserializer;
import org.klojang.util.path.ObjectReader;
import org.klojang.util.path.ObjectWriter;
import org.klojang.util.path.Path;
import org.klojang.util.path.PathWalkerException;
import org.klojang.util.x.Param;

/**
 * A {@code PathWalker} lets you read and write deeply nested values using {@link Path} objects. It
 * can read almost any type of object it encounters as it walks down the path towards the last path
 * segment: JavaBeans, maps, collections, arrays, scalars, and opaque types like {@code String}. It
 * can also write to most of them. A {@code PathWalker} can be useful when processing large batches
 * of sparsely populated maps or objects and/or it doesn't really matter whether a deeply nested
 * value is {@code null} or just not present at all. By default, the {@code PathWalker} will return
 * {@code null} in either case (although you can change this).
 *
 * @author Ayco Holleman
 */
@SuppressWarnings({&quot;unchecked&quot;})
public final class PathWalker {

  private static final String PATHS = &quot;paths&quot;;

  private final Path[] paths;
  private final boolean se;
  private final KeyDeserializer kd;

  /**
   * Creates a {@code PathWalker} for the specified paths.
   *
   * @param paths One or more paths representing possibly deeply-nested properties
   */
<span class="fc" id="L43">  public PathWalker(Path... paths) {</span>
<span class="fc" id="L44">    Check.that(paths, PATHS).isNot(empty()).is(deepNotNull());</span>
<span class="fc" id="L45">    this.paths = Arrays.copyOf(paths, paths.length);</span>
<span class="fc" id="L46">    this.se = true;</span>
<span class="fc" id="L47">    this.kd = null;</span>
<span class="fc" id="L48">  }</span>

  /**
   * Creates a {@code PathWalker} for the specified paths.
   *
   * @param paths The paths to walk through the provided host objects
   */
<span class="fc" id="L55">  public PathWalker(String... paths) {</span>
<span class="fc" id="L56">    Check.that(paths, PATHS).isNot(empty()).is(deepNotNull());</span>
<span class="fc" id="L57">    this.paths = Arrays.stream(paths).map(Path::from).toArray(Path[]::new);</span>
<span class="fc" id="L58">    this.se = true;</span>
<span class="fc" id="L59">    this.kd = null;</span>
<span class="fc" id="L60">  }</span>

  /**
   * Creates a {@code PathWalker} for the specified paths.
   *
   * @param paths The paths to walk through the provided host objects
   */
  public PathWalker(List&lt;Path&gt; paths) {
<span class="fc" id="L68">    this(paths, true);</span>
<span class="fc" id="L69">  }</span>

  /**
   * Creates a {@code PathWalker} for the specified paths.
   *
   * @param paths The action to take if a path could not be read or written
   * @param suppressExceptions If {@code true}, the {@code read} methods will return {@code null}
   *     for paths that could not be read. The {@code write} methods will quietly return without
   *     having written the value. If {@code false}, a {@link PathWalkerException} will be thrown
   *     detailing the error.
   */
<span class="fc" id="L80">  public PathWalker(List&lt;Path&gt; paths, boolean suppressExceptions) {</span>
<span class="fc" id="L81">    Check.that(paths, PATHS).isNot(empty()).is(deepNotNull());</span>
<span class="fc" id="L82">    this.paths = paths.toArray(Path[]::new);</span>
<span class="fc" id="L83">    this.se = suppressExceptions;</span>
<span class="fc" id="L84">    this.kd = null;</span>
<span class="fc" id="L85">  }</span>

  /**
   * Creates a {@code PathWalker} for the specified paths.
   *
   * @param paths The paths to walk
   * @param suppressExceptions If {@code true}, the {@code read} methods will return {@code null}
   *     for paths that could not be read. The {@code write} methods will quietly return without
   *     having written the value. If {@code false}, a {@link PathWalkerException} will be thrown
   *     detailing the error.
   * @param keyDeserializer A function that converts path segments to map keys. You need to provide
   *     this if the host objects are, or contain, {@link Map} instances with non-string keys.
   */
<span class="fc" id="L98">  public PathWalker(List&lt;Path&gt; paths, boolean suppressExceptions, KeyDeserializer keyDeserializer) {</span>
<span class="fc" id="L99">    Check.that(paths, PATHS).is(deepNotEmpty());</span>
<span class="fc" id="L100">    Check.notNull(keyDeserializer, &quot;keyDeserializer&quot;);</span>
<span class="fc" id="L101">    this.paths = paths.toArray(Path[]::new);</span>
<span class="fc" id="L102">    this.se = suppressExceptions;</span>
<span class="fc" id="L103">    this.kd = keyDeserializer;</span>
<span class="fc" id="L104">  }</span>

  // For internal use
<span class="fc" id="L107">  PathWalker(Path path, boolean suppressExceptions, KeyDeserializer keyDeserializer) {</span>
<span class="fc" id="L108">    this.paths = new Path[] {path};</span>
<span class="fc" id="L109">    this.se = suppressExceptions;</span>
<span class="fc" id="L110">    this.kd = keyDeserializer;</span>
<span class="fc" id="L111">  }</span>

  /**
   * Returns the values of all paths specified through the constructor.
   *
   * @param host the object to read the values from
   * @return the values of all paths specified through the constructor
   * @throws PathWalkerException If {@code suppressExceptions} is false and the {@code PathWalker}
   *     fails to retrieve the values of one or more paths.
   */
  public Object[] readValues(Object host) throws PathWalkerException {
<span class="fc" id="L122">    ObjectReader reader = new ObjectReader(se, kd);</span>
<span class="fc" id="L123">    return Arrays.stream(paths).map(path -&gt; reader.read(host, path, 0)).toArray();</span>
  }

  /**
   * Reads the values of all paths specified through the constructor.
   *
   * @param host the object to read the path values from
   * @param output an array into which to place the values. The length of the output array must be
   *     equal to, or greater than the number of paths specified through the constructor.
   * @throws PathWalkerException If {@code suppressExceptions} is false and the {@code PathWalker}
   *     fails to retrieve the values of one or more paths.
   */
  public void readValues(Object host, Object[] output) throws PathWalkerException {
<span class="fc" id="L136">    Check.notNull(output, Param.OUTPUT).has(length(), gte(), paths.length);</span>
<span class="fc" id="L137">    ObjectReader reader = new ObjectReader(se, kd);</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">    for (int i = 0; i &lt; paths.length; ++i) {</span>
<span class="fc" id="L139">      output[i] = reader.read(host, paths[i], 0);</span>
    }
<span class="fc" id="L141">  }</span>

  /**
   * Reads the values of all paths and inserts them into the provided path-to-value map.
   *
   * @param host the object from which to read the values
   * @param output The {@code Map} into which to put the values
   * @throws PathWalkerException If {@code suppressExceptions} is false and the {@code PathWalker}
   *     fails to retrieve the values of one or more paths.
   */
  public void readValues(Object host, Map&lt;Path, Object&gt; output) throws PathWalkerException {
<span class="fc" id="L152">    Check.notNull(output, Param.OUTPUT);</span>
<span class="fc" id="L153">    ObjectReader reader = new ObjectReader(se, kd);</span>
<span class="fc" id="L154">    Arrays.stream(paths).forEach(p -&gt; output.put(p, reader.read(host, p, 0)));</span>
<span class="fc" id="L155">  }</span>

  /**
   * Reads the value of the first path specified through the constructor. Convenient if you
   * specified just one path.
   *
   * @param &lt;T&gt; The type of the value being returned
   * @param host the object from which to read the value
   * @return the value of the first path specified through the constructor
   * @throws PathWalkerException If {@code suppressExceptions} is false and the {@code PathWalker}
   *     fails to retrieve the value of the first path.
   */
  public &lt;T&gt; T read(Object host) {
<span class="fc" id="L168">    return (T) new ObjectReader(se, kd).read(host, paths[0], 0);</span>
  }

  /**
   * Sets the values of the paths specified through the constructor. The provided array of values
   * must have the same length as the number of paths.
   *
   * @param host the object to which to write the values
   * @param values The values to write
   * @return the number of successfully written values
   */
  public int writeValues(Object host, Object... values) {
<span class="fc" id="L180">    Check.notNull(values, Param.VALUES).has(length(), eq(), paths.length);</span>
<span class="fc" id="L181">    ObjectWriter writer = new ObjectWriter(se, kd);</span>
<span class="fc" id="L182">    int x = 0;</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">    for (int i = 0; i &lt; paths.length; ++i) {</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">      if (writer.write(host, paths[i], values[i])) {</span>
<span class="fc" id="L185">        ++x;</span>
      }
    }
<span class="fc" id="L188">    return x;</span>
  }

  /**
   * Sets the value of the first path specified through the constructor. Convenient if you specified
   * just one path.
   *
   * @param host the object to write the value to
   * @param value The value to write
   * @return {@code true} if the value was successfully written
   */
  public boolean write(Object host, Object value) {
<span class="fc" id="L200">    return new ObjectWriter(se, kd).write(host, paths[0], value);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>