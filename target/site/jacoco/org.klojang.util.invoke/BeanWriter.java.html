<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BeanWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Klojang Check</a> &gt; <a href="index.source.html" class="el_package">org.klojang.util.invoke</a> &gt; <span class="el_source">BeanWriter.java</span></div><h1>BeanWriter.java</h1><pre class="source lang-java linenums">package org.klojang.util.invoke;

import org.klojang.check.Check;
import org.klojang.check.fallible.FallibleBiFunction;
import org.klojang.util.Morph;
import org.klojang.util.TypeConversionException;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import static org.klojang.check.CommonChecks.empty;
import static org.klojang.check.CommonChecks.notNull;
import static org.klojang.util.invoke.IncludeExclude.INCLUDE;
import static org.klojang.util.invoke.NoSuchPropertyException.noSuchProperty;
import static org.klojang.util.x.Param.BEAN;
import static org.klojang.util.x.Param.PROPERTY;

/**
 * A dynamic bean writer class. This class uses the {@code java.lang.invoke} package
 * instead of reflection to read bean properties. Yet it still uses reflection to
 * identify the public getters of the bean class. Therefore, if you use this class
 * from within a Java module you must open the module to the naturalis-common
 * module.
 *
 * @param &lt;T&gt; The type of the bean
 * @author Ayco Holleman
 */
public final class BeanWriter&lt;T&gt; {

  /**
   * Returns a {@code BeanWriter} that allows for &quot;loose typing&quot; of the values to be
   * assigned to the bean's properties. A {@link Morph} object will be used to adapt
   * input values to the type of the destination property. You can optionally specify
   * an array of properties that you intend to write. If you specify a zero-length
   * array, all properties will be writable. If you intend to use this
   * {@code BeanWriter} to repetitively write just one or two properties on bulky
   * bean types, explicitly specifying the properties you intend to write might make
   * the {@code BeanWriter} slightly more efficient.
   *
   * @param &lt;U&gt; The type of the bean
   * @param beanClass the bean class
   * @param properties the properties you allow to be written
   * @return a {@code BeanWriter} with &quot;loose typing&quot; behavior
   */
  public static &lt;U&gt; BeanWriter&lt;U&gt; getTolerantWriter(Class&lt;U&gt; beanClass,
      String... properties) {
<span class="nc" id="L48">    return new BeanWriter&lt;&gt;(beanClass,</span>
<span class="nc" id="L49">        (setter, value) -&gt; Morph.convert(value, setter.getParamType()),</span>
        INCLUDE,
        properties);
  }

  private final Class&lt;T&gt; beanClass;
  private final FallibleBiFunction&lt;Setter, Object, Object, Throwable&gt; converter;
  private final Map&lt;String, Setter&gt; setters;

  /**
   * Creates a {@code BeanWriter} for the specified class. You can optionally specify
   * an array of properties that you intend to write. If you specify a zero-length
   * array, all properties will be writable. If you intend to use this
   * {@code BeanWriter} to repetitively write just one or two properties on bulky
   * bean types, explicitly specifying the properties you intend to write might make
   * the {@code BeanWriter slightly more efficient.
   *
   * @param beanClass the bean class
   * @param properties the properties to be written
   */
  public BeanWriter(Class&lt;T&gt; beanClass, String... properties) {
<span class="fc" id="L70">    this(beanClass, INCLUDE, properties);</span>
<span class="fc" id="L71">  }</span>

  /**
   * Creates a {@code BeanWriter} for the specified class. You can optionally specify
   * an array of properties that you intend to write. If you specify a zero-length
   * array all properties will be writable. Input values will first be converted by
   * the specified conversion function before being assigned to properties.
   *
   * @param beanClass the bean class
   * @param converter a conversion function for input values. The conversion is
   *     given the {@link Setter} for the property to be set as the first argument,
   *     and the input value as the second argument. The return value should be the
   *     actual value to assign to the property. The {@code Setter} should only be
   *     used to get the {@link Setter#getProperty() name} and
   *     {@link Setter#getParamType() type} of the property to be set. You &lt;i&gt;should
   *     not&lt;/i&gt; use it to actually {@link Setter#write(Object, Object) write} the
   *     property, as this will happen anyhow once the conversion function returns.
   *     Unless the conversion fails for extraordinary reasons, it should throw an
   *     {@link IllegalAssignmentException} upon failure. You can again use the
   *     {@code Setter} to {@link Setter#illegalAssignment(Object) generate} the
   *     exception.
   * @param properties the properties you allow to be written
   */
  public BeanWriter(Class&lt;T&gt; beanClass,
      FallibleBiFunction&lt;Setter, Object, Object, Throwable&gt; converter,
      String... properties) {
<span class="fc" id="L97">    this(beanClass, converter, INCLUDE, properties);</span>
<span class="fc" id="L98">  }</span>

  /**
   * Creates a {@code BeanWriter} for the specified class. You can optionally specify
   * an array of properties that you intend or do &lt;i&gt;not&lt;/i&gt; intend to write. If you
   * specify a zero-length array all properties will be writable.
   *
   * @param beanClass the bean class
   * @param includeExclude whether to include or exclude the specified
   *     properties
   * @param properties the properties to be included/excluded
   */
  public BeanWriter(Class&lt;T&gt; beanClass,
      IncludeExclude includeExclude,
<span class="fc" id="L112">      String... properties) {</span>
<span class="fc" id="L113">    this.beanClass = Check.notNull(beanClass, &quot;beanClass&quot;).ok();</span>
<span class="fc" id="L114">    this.converter = null;</span>
<span class="fc" id="L115">    Check.notNull(includeExclude, &quot;includeExclude&quot;);</span>
<span class="fc" id="L116">    Check.notNull(properties, &quot;properties&quot;);</span>
<span class="fc" id="L117">    this.setters = getSetters(includeExclude, properties);</span>
<span class="fc" id="L118">  }</span>

  /**
   * Creates a {@code BeanWriter} for the specified class. You can optionally specify
   * an array of properties that you intend or do &lt;i&gt;not&lt;/i&gt; intend to write. If you
   * specify a zero-length array all properties will be writable. If you intend to
   * use this {@code BeanWriter} to repetitively write just one or two properties
   * from bulky bean types, explicitly specifying the properties you intend to write
   * might make the {@code BeanWriter} more efficient. Input values will first be
   * converted by the specified conversion function before being assigned to
   * properties.
   *
   * &lt;p&gt;&lt;i&gt;Specifying one or more non-existent properties will not cause an
   * exception to be thrown.&lt;/i&gt; They will be quietly ignored.
   *
   * @param beanClass the bean class
   * @param converter A conversion function for input values. The conversion is
   *     given the {@link Setter} for the property to be set as the first argument,
   *     and the input value as the second argument. The return value should be the
   *     actual value to assign to the property. The {@code Setter} should only be
   *     used to get the {@link Setter#getProperty() name} and
   *     {@link Setter#getParamType() type} of the property to be set. You &lt;i&gt;should
   *     not&lt;/i&gt; use it to actually {@link Setter#write(Object, Object) write} the
   *     property, as this will happen anyhow once the conversion function returns.
   *     Unless the conversion fails for extraordinary reasons, it should throw an
   *     {@link IllegalAssignmentException} upon failure. You can again use the
   *     {@code Setter} to {@link Setter#illegalAssignment(Object) generate} the
   *     exception.
   * @param includeExclude whether to include or exclude the specified
   *     properties
   * @param properties the properties to be included/excluded
   */
  public BeanWriter(Class&lt;T&gt; beanClass,
      FallibleBiFunction&lt;Setter, Object, Object, Throwable&gt; converter,
      IncludeExclude includeExclude,
<span class="fc" id="L153">      String... properties) {</span>
<span class="fc" id="L154">    this.beanClass = Check.notNull(beanClass, &quot;beanClass&quot;).ok();</span>
<span class="fc" id="L155">    this.converter = Check.notNull(converter, &quot;converter&quot;).ok();</span>
<span class="fc" id="L156">    Check.notNull(includeExclude, &quot;includeExclude&quot;);</span>
<span class="fc" id="L157">    Check.notNull(properties, &quot;properties&quot;);</span>
<span class="fc" id="L158">    this.setters = getSetters(includeExclude, properties);</span>
<span class="fc" id="L159">  }</span>

  /**
   * Sets the value of the specified property on the specified bean.
   *
   * @param bean The bean instance
   * @param property The property
   * @param value The value to set it to
   * @throws IllegalAssignmentException If the value cannot be cast to the type
   *     of the property, or if the value is {@code null} and the property has a
   *     primitive type. This is a {@link RuntimeException}, but you might still want
   *     to catch it as it can often be handled in a meaningful way.
   * @throws Throwable The {@code Throwable} thrown from inside the
   *     {@code java.lang.invoke} package
   */
  public void write(T bean, String property, Object value) throws Throwable {
<span class="fc" id="L175">    Check.notNull(bean, BEAN);</span>
<span class="fc" id="L176">    Setter setter = Check.notNull(property, PROPERTY).ok(setters::get);</span>
<span class="fc" id="L177">    Check.that(setter).is(notNull(), () -&gt; noSuchProperty(bean, property));</span>
<span class="fc" id="L178">    set(bean, setter, value);</span>
<span class="fc" id="L179">  }</span>

  /**
   * Overwrites all properties in the second bean with the values they have in the
   * first bean. This can potentially nullify non-null properties in the target
   * bean.
   *
   * @param fromBean The bean from which to copy the values.
   * @param toBean The bean to which to copy the values.
   * @throws Throwable The {@code Throwable} thrown from inside the
   *     {@code java.lang.invoke} package
   */
  public void copy(T fromBean, T toBean) throws Throwable {
<span class="fc" id="L192">    Check.notNull(fromBean, &quot;source bean&quot;);</span>
<span class="fc" id="L193">    Check.notNull(toBean, &quot;target bean&quot;);</span>
<span class="fc" id="L194">    BeanReader&lt;T&gt; reader = getBeanReader();</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">    for (Setter setter : setters.values()) {</span>
<span class="fc" id="L196">      set(toBean, setter, reader.read(fromBean, setter.getProperty()));</span>
<span class="fc" id="L197">    }</span>
<span class="fc" id="L198">  }</span>

  /**
   * Copies all non-null properties from the first bean to the second bean. This can
   * potentially overwrite non-null properties in the second bean, but it will never
   * nullify them.
   *
   * @param fromBean The bean from which to copy the values.
   * @param toBean The bean to which to copy the values.
   * @throws Throwable The {@code Throwable} thrown from inside the
   *     {@code java.lang.invoke} package
   */
  public void copyNonNull(T fromBean, T toBean) throws Throwable {
<span class="fc" id="L211">    Check.notNull(fromBean, &quot;source bean&quot;);</span>
<span class="fc" id="L212">    Check.notNull(toBean, &quot;target bean&quot;);</span>
<span class="fc" id="L213">    BeanReader&lt;T&gt; reader = getBeanReader();</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">    for (Setter setter : setters.values()) {</span>
<span class="fc" id="L215">      Object v = reader.read(fromBean, setter.getProperty());</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">      if (v != null) {</span>
<span class="fc" id="L217">        set(toBean, setter, v);</span>
      }
<span class="fc" id="L219">    }</span>
<span class="fc" id="L220">  }</span>

  /**
   * Overwrites all properties in the second bean whose value is {@code null} with
   * the values they have in the first bean. Non-null properties in the second bean
   * are left alone.
   *
   * @param fromBean The bean from which to copy the values.
   * @param toBean The bean to which to copy the values.
   * @throws Throwable The {@code Throwable} thrown from inside the
   *     {@code java.lang.invoke} package
   */
  public void enrich(T fromBean, T toBean) throws Throwable {
<span class="fc" id="L233">    Check.notNull(fromBean, &quot;source bean&quot;);</span>
<span class="fc" id="L234">    Check.notNull(toBean, &quot;target bean&quot;);</span>
<span class="fc" id="L235">    BeanReader&lt;T&gt; reader = getBeanReader();</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">    for (Setter setter : setters.values()) {</span>
<span class="fc" id="L237">      Object v = reader.read(fromBean, setter.getProperty());</span>
<span class="fc bfc" id="L238" title="All 4 branches covered.">      if (v != null &amp;&amp; reader.read(toBean, setter.getProperty()) == null) {</span>
<span class="fc" id="L239">        set(toBean, setter, v);</span>
      }
<span class="fc" id="L241">    }</span>
<span class="fc" id="L242">  }</span>

  /**
   * Overwrites all properties in the specified bean with the corresponding values in
   * the specified map. This can potentially nullify non-null values in the target
   * bean.
   *
   * @param fromMap The {@code Map} providing the data for the JavaBean
   * @param toBean The JavaBean to populate
   * @throws IllegalAssignmentException If a value cannot be cast or converted to
   *     the type of the destination property, or if the value is {@code null} and
   *     the destination property has a primitive type. This is a
   *     {@link RuntimeException}, but you might still want to catch it as it can
   *     often be handled in a meaningful way.
   * @throws Throwable The {@code Throwable} thrown from inside the
   *     {@code java.lang.invoke} package
   */
  public void copy(Map&lt;String, ?&gt; fromMap, T toBean)
      throws IllegalAssignmentException, Throwable {
<span class="fc" id="L261">    Check.notNull(fromMap, &quot;fromMap&quot;);</span>
<span class="fc" id="L262">    Check.notNull(toBean, &quot;toBean&quot;);</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">    for (Map.Entry&lt;String, ?&gt; e : fromMap.entrySet()) {</span>
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">      if (e.getKey() != null) {</span>
<span class="fc" id="L265">        Setter setter = setters.get(e.getKey());</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">        if (setter != null) {</span>
<span class="fc" id="L267">          set(toBean, setter, e.getValue());</span>
        }
      }
<span class="fc" id="L270">    }</span>
<span class="fc" id="L271">  }</span>

  /**
   * Copies all non-null values from the specified map to the specified bean. Map
   * keys that do not correspond to bean properties are quietly ignored.
   *
   * @param fromMap The {@code Map} providing the data for the JavaBean
   * @param toBean The JavaBean to populate
   * @throws IllegalAssignmentException If a value cannot be cast or converted to
   *     the type of the destination property, or if the value is {@code null} and
   *     the destination property has a primitive type. This is a
   *     {@link RuntimeException}, but you might still want to catch it as it can
   *     often be handled in a meaningful way.
   * @throws Throwable The {@code Throwable} thrown from inside the
   *     {@code java.lang.invoke} package
   */
  public void copyNonNull(Map&lt;String, ?&gt; fromMap, T toBean) throws Throwable {
<span class="fc" id="L288">    Check.notNull(fromMap, &quot;source map&quot;);</span>
<span class="fc" id="L289">    Check.notNull(toBean, &quot;target bean&quot;);</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">    for (Map.Entry&lt;String, ?&gt; e : fromMap.entrySet()) {</span>
<span class="pc bpc" id="L291" title="1 of 4 branches missed.">      if (e.getValue() != null &amp;&amp; e.getKey() != null) {</span>
<span class="fc" id="L292">        Setter setter = setters.get(e.getKey());</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">        if (setter != null) {</span>
<span class="fc" id="L294">          set(toBean, setter, e.getValue());</span>
        }
      }
<span class="fc" id="L297">    }</span>
<span class="fc" id="L298">  }</span>

  /**
   * Overwrites all properties in the specified bean whose value is {@codd null} with
   * the corresponding values in the specified map. Non-null properties in the target
   * bean are left alone.
   *
   * @param fromMap The {@code Map} providing the data for the JavaBean
   * @param toBean The JavaBean to populate
   * @throws IllegalAssignmentException If a value cannot be cast or converted to
   *     the type of the destination property, or if the value is {@code null} and
   *     the destination property has a primitive type. This is a
   *     {@link RuntimeException}, but you might still want to catch it as it can
   *     often be handled in a meaningful way.
   * @throws Throwable The {@code Throwable} thrown from inside the
   *     {@code java.lang.invoke} package
   */
  public void enrich(Map&lt;String, ?&gt; fromMap, T toBean)
      throws IllegalAssignmentException, Throwable {
<span class="fc" id="L317">    Check.notNull(fromMap, &quot;fromMap&quot;);</span>
<span class="fc" id="L318">    Check.notNull(toBean, &quot;toBean&quot;);</span>
<span class="fc" id="L319">    BeanReader&lt;T&gt; reader = getBeanReader();</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">    for (Map.Entry&lt;String, ?&gt; e : fromMap.entrySet()) {</span>
<span class="pc bpc" id="L321" title="1 of 4 branches missed.">      if (e.getValue() != null &amp;&amp; e.getKey() != null) {</span>
<span class="fc" id="L322">        Setter setter = setters.get(e.getKey());</span>
<span class="pc bpc" id="L323" title="1 of 4 branches missed.">        if (setter != null &amp;&amp; reader.read(toBean, e.getKey()) == null) {</span>
<span class="fc" id="L324">          set(toBean, setter, e.getValue());</span>
        }
      }
<span class="fc" id="L327">    }</span>
<span class="fc" id="L328">  }</span>

  /**
   * Returns the type of the objects this {@code BeanWriter} can write to.
   *
   * @return The type of the objects this {@code BeanWriter} can write to
   */
  public Class&lt;? super T&gt; getBeanClass() {
<span class="nc" id="L336">    return beanClass;</span>
  }

  /**
   * Returns {@code true} if the specified string represents a property that can be
   * written by this {@code BeanWriter}. Note that this check is already done by the
   * {@link #write(Object, String, Object)} method before it will actually attempt to
   * set the property. Only perform this check if there is a considerable chance that
   * the provided string is &lt;i&gt;not&lt;/i&gt; a writable property.
   *
   * @param property the string to be tested
   * @return {@code true} if the specified string represents a property that can be
   *     written by this {@code BeanWriter}
   */
  public boolean canWrite(String property) {
<span class="nc" id="L351">    return setters.keySet().contains(property);</span>
  }

  /**
   * Returns the properties that this {@code BeanWriter} will write. That will be all
   * write-accessible properties minus the properties excluded through the
   * constructor (if any).
   *
   * @return the properties that this {@code BeanWriter} will write
   */
  public Set&lt;String&gt; getWritableProperties() {
<span class="nc" id="L362">    return setters.keySet();</span>
  }

  /**
   * Returns the {@link Setter setters} used by the {@code BeanWriter} to write bean
   * properties. The returned {@code Map} maps the name of a property to the
   * {@code Setter} used to write it.
   *
   * @return The {@link Setter setters} used by the {@code BeanWriter} to write bean
   *     properties.
   */
  public Map&lt;String, Setter&gt; getIncludedSetters() {
<span class="nc" id="L374">    return setters;</span>
  }

  private Map&lt;String, Setter&gt; getSetters(IncludeExclude ie, String[] props) {
<span class="fc" id="L378">    Map&lt;String, Setter&gt; tmp = SetterFactory.INSTANCE.getSetters(beanClass);</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">    if (props.length != 0) {</span>
<span class="fc" id="L380">      tmp = new HashMap&lt;&gt;(tmp);</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">      if (ie.isExclude()) {</span>
<span class="fc" id="L382">        tmp.keySet().removeAll(Set.of(props));</span>
      } else {
<span class="fc" id="L384">        tmp.keySet().retainAll(Set.of(props));</span>
      }
<span class="pc" id="L386">      Check.that(tmp).isNot(empty(), () -&gt; new NoPublicSettersException(beanClass));</span>
<span class="fc" id="L387">      tmp = Map.copyOf(tmp);</span>
    }
<span class="fc" id="L389">    return tmp;</span>
  }

  private void set(T bean, Setter setter, Object value) throws Throwable {
<span class="fc bfc" id="L393" title="All 2 branches covered.">    if (converter == null) {</span>
<span class="fc" id="L394">      setter.write(bean, value);</span>
    } else {
      Object val;
      try {
<span class="fc" id="L398">        val = converter.apply(setter, value);</span>
<span class="nc" id="L399">      } catch (TypeConversionException e) {</span>
<span class="nc" id="L400">        throw setter.illegalAssignment(value);</span>
<span class="fc" id="L401">      }</span>
<span class="fc" id="L402">      setter.write(bean, val);</span>
    }
<span class="fc" id="L404">  }</span>

  private BeanReader&lt;T&gt; beanReader;

  private BeanReader&lt;T&gt; getBeanReader() {
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">    if (beanReader == null) {</span>
<span class="fc" id="L410">      beanReader = new BeanReader&lt;&gt;(beanClass,</span>
<span class="fc" id="L411">          setters.keySet().toArray(String[]::new));</span>
    }
<span class="fc" id="L413">    return beanReader;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>