<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MapBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Klojang Check</a> &gt; <a href="index.source.html" class="el_package">org.klojang.util.util</a> &gt; <span class="el_source">MapBuilder.java</span></div><h1>MapBuilder.java</h1><pre class="source lang-java linenums">package org.klojang.util.util;

import static org.klojang.check.CommonChecks.EQ;
import static org.klojang.check.CommonChecks.NULL;
import static org.klojang.check.CommonChecks.empty;
import static org.klojang.check.CommonChecks.gt;
import static org.klojang.check.CommonChecks.instanceOf;
import static org.klojang.check.CommonChecks.notNull;
import static org.klojang.check.CommonChecks.sameAs;
import static org.klojang.check.CommonExceptions.STATE;
import static org.klojang.check.CommonProperties.strlen;
import static org.klojang.util.ObjectMethods.ifNull;
import static org.klojang.util.ObjectMethods.replaceIf;

import java.util.LinkedHashMap;
import java.util.Map;

import org.klojang.check.Check;
import org.klojang.check.aux.Result;
import org.klojang.util.path.Path;
import org.klojang.util.x.Param;

/**
 * &lt;p&gt;An elaborate {@code Builder} for {@code Map&lt;String, Object&gt;} pseudo-objects. A
 * {@code MapBuilder} lets you write deeply nested values without having to create
 * the intermediate maps first. If they are missing, they will tacitly be created.
 * Map keys must not be {@code null} or an empty string. Map values can be anything,
 * including {@code null}.
 *
 * &lt;p&gt;Internally, a {@code MapBuilder} works with {@link Path} objects. See the
 * documentation for the {@code Path} class for how to specify path strings.
 *
 * &lt;p&gt;&lt;b&gt;Example 1:&lt;/b&gt;
 *
 * &lt;blockquote&gt;&lt;pre&gt;{@code
 * MapBuilder mb = new MapBuilder();
 * mb.set(&quot;person.address.street&quot;, &quot;12 Revolutionary Rd.&quot;)
 *  .set(&quot;person.address.state&quot;, &quot;CA&quot;)
 *  .set(&quot;person.firstName&quot;, &quot;John&quot;)
 *  .set(&quot;person.lastName&quot;, &quot;Smith&quot;)
 *  .set(&quot;person.dateOfBirth&quot;, LocalDate.of(1967, 4, 4));
 * Map&lt;String, Object&gt; map = mb.createMap();
 * }&lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;&lt;b&gt;Example 2:&lt;/b&gt;
 *
 * &lt;blockquote&gt;&lt;pre&gt;{@code
 * Map&lt;String, Object&gt; map = new MapBuilder()
 *  .in(&quot;person&quot;)
 *    .set(&quot;firstName&quot;, &quot;John&quot;)
 *    .set(&quot;lastName&quot;, &quot;Smith&quot;)
 *    .set(&quot;dateOfBirth&quot;, LocalDate.of(1967, 4, 4))
 *    .in(&quot;address&quot;)
 *      .set(&quot;street&quot;, &quot;12 Revolutionary Rd.&quot;)
 *      .set(&quot;state&quot;, &quot;CA&quot;)
 *      .up(&quot;person&quot;)
 *    .in(&quot;medical_status&quot;)
 *      .set(&quot;allergies&quot;, false)
 *      .set(&quot;smoker&quot;, true)
 *      .set(&quot;prescriptions&quot;, null)
 *  .createMap();
 * }&lt;/pre&gt;&lt;/blockquote&gt;
 *
 * @author Ayco Holleman
 */
public final class MapBuilder {

  /**
   * Thrown when trying to write to a path that has already been set, or that extends
   * beyond a path segment with a terminal value (anything other than a map).
   *
   * @author Ayco Holleman
   */
  public static class PathBlockedException extends IllegalArgumentException {

    private PathBlockedException(Path path, Object value) {
<span class="fc" id="L77">      super(createMessage(path, value));</span>
<span class="fc" id="L78">    }</span>

    private static String createMessage(Path path, Object value) {
<span class="fc" id="L81">      String fmt = &quot;path \&quot;%s\&quot; blocked by terminal value %s&quot;;</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">      if (value instanceof String s) {</span>
<span class="fc" id="L83">        value = '&quot;' + s + '&quot;';</span>
      }
<span class="fc" id="L85">      return String.format(fmt, path, value);</span>
    }

  }

  /*
   * When setting a path, or when processing the source map passed to the
   * constructor, we replace null with this value. This way, if Map.get(key) returns
   * null, we know for sure that the map does not contain the key. No need to follow
   * it up with a containsKey call. On its way out, _NULL_ is replaced again with
   * null.
   */
<span class="fc" id="L97">  private static final Object _NULL_ = new Object();</span>

  private static final String ERR_HOME_ALREADY = &quot;already in root map&quot;;

  /**
   * Creates a new {@code MapBuilder}.
   *
   * @return a new {@code MapBuilder}
   */
  public static MapBuilder begin() {
<span class="fc" id="L107">    return new MapBuilder();</span>
  }

  /**
   * Creates a {@code MapBuilder} that starts out with the entries in the specified
   * map. The map is read, but not modified.
   *
   * @param map The initial {@code Map}
   * @return a {@code MapBuilder} that starts out with the entries in the specified
   *     map
   */
  public static MapBuilder begin(Map&lt;String, Object&gt; map) {
<span class="fc" id="L119">    return new MapBuilder(map);</span>
  }

  private final Map&lt;String, Object&gt; map;
  private final Path root;
  private final MapBuilder parent;

  /**
   * Creates a new {@code MapBuilder}.
   */
  public MapBuilder() {
<span class="fc" id="L130">    this(new LinkedHashMap&lt;&gt;());</span>
<span class="fc" id="L131">  }</span>

  /**
   * Creates a {@code MapBuilder} that starts out with the entries in the specified
   * map. The map is read, but not modified.
   *
   * @param map The initial {@code Map}
   */
<span class="fc" id="L139">  public MapBuilder(Map&lt;String, Object&gt; map) {</span>
<span class="fc" id="L140">    Check.notNull(map, Param.MAP);</span>
<span class="fc" id="L141">    this.map = new LinkedHashMap&lt;&gt;(map.size() + 10);</span>
<span class="fc" id="L142">    this.root = Path.empty();</span>
<span class="fc" id="L143">    this.parent = null;</span>
<span class="fc" id="L144">    init(this, map);</span>
<span class="fc" id="L145">  }</span>

<span class="fc" id="L147">  private MapBuilder(Path root, MapBuilder parent) {</span>
<span class="fc" id="L148">    this.root = root;</span>
<span class="fc" id="L149">    this.map = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L150">    this.parent = parent;</span>
<span class="fc" id="L151">  }</span>

  /**
   * &lt;p&gt;Sets the specified path to the specified value. It is not allowed to
   * overwrite the value of a path that has already been set, even if set to
   * {@code null}. If necessary, use {@link #unset(String)} to unset the path's value
   * first.
   *
   * &lt;p&gt;It is not allowed to directly set the path to a value of type {@code Map}.
   * Use the {@link #in(String) in} method to create a new map at the specified path.
   * It is allowed to set a path's value to {@code null}.
   *
   * @param path the path at which to write the value
   * @param value the value
   * @return this {@code MapBuilder}
   */
  public MapBuilder set(String path, Object value) {
<span class="fc" id="L168">    Check.notNull(path, Param.PATH);</span>
<span class="fc" id="L169">    set(this, Path.from(path), value);</span>
<span class="fc" id="L170">    return this;</span>
  }

  /**
   * Returns a {@link Result} object containing the value of the specified path, or
   * {@link Result#notAvailable} if the path is not set.
   *
   * @param path the path
   * @return a {@link Result} object containing the value of the specified path, or
   *     {@link Result#notAvailable} if the path is not set
   * @see #isSet(String)
   */
  public Result&lt;Object&gt; poll(String path) {
<span class="fc" id="L183">    Check.notNull(path, Param.PATH);</span>
<span class="fc" id="L184">    return poll(this, Path.from(path));</span>
  }

  /**
   * Returns the value of the specified path if set, else {@code null}.
   *
   * @param path the path
   * @param &lt;T&gt; The type to cast the path's value to
   * @return the value of the specified path if set, else {@code null}
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public &lt;T&gt; T get(String path) {
<span class="fc" id="L196">    return (T) poll(path).orElse(null);</span>
  }

  /**
   * Returns a {@code MapBuilder} for the map at the specified path. Once this method
   * has been called, &lt;i&gt;all&lt;/i&gt; paths subsequently specified (including for
   * subsequent calls to {@code in}) will be taken relative to the specified path. If
   * there is no map yet at the specified path, it will be created. Ancestral maps
   * will be created as well, as and when needed. If any of the segments in the path
   * (including the last segment) has already been set, a
   * {@link PathBlockedException} is thrown.
   *
   * @param path the path to be used as the base path. The path will itself be
   *     interpreted as relative to the &lt;i&gt;current&lt;/i&gt; base path
   * @return a {@code MapBuilder} for the map found or created at the specified path
   */
  public MapBuilder in(String path) {
<span class="fc" id="L213">    Check.notNull(path, Param.PATH);</span>
<span class="fc" id="L214">    return in(this, Path.from(path));</span>
  }

  /**
   * Jumps to another branch in the tree of nested maps. The difference between
   * {@code jump} and {@link #in(String) in} is that the path passed to {@code jump}
   * is always taken as an absolute path (i.e. relative to the root map), while the
   * path passed to {@code in} is taken relative to the path(s) passed to previous
   * calls to {@code in} and {@code jump}.
   *
   * @param path the absolute path to be used as the base path
   * @return a {@code MapBuilder} for the map found or created at the specified path
   * @see #in(String)
   */
  public MapBuilder jump(String path) {
<span class="fc bfc" id="L229" title="All 2 branches covered.">    return parent == null ? in(path) : reset().in(path);</span>
  }

  /**
   * &lt;p&gt;Returns a {@code MapBuilder} for the parent map of the map currently being
   * written. All subsequently specified paths will be taken relative to the parent
   * map's path. An {@link IllegalStateException} is thrown when trying to exit out
   * of the root map. This method must be passed the name of the parent map (the last
   * segment of the parent map's path). An {@link IllegalArgumentException} is thrown
   * if the argument does not equal the parent map's name. This is to make sure you
   * will not accidentally start writing to the wrong map, and it makes the
   * map-building code more intelligible.
   *
   * &lt;blockquote&gt;&lt;pre&gt;{@code
   * Map&lt;String, Object&gt; map = new MapBuilder()
   *  .in(&quot;person&quot;)
   *    .set(&quot;firstName&quot;, &quot;John&quot;)
   *    .set(&quot;lastName&quot;, &quot;Smith&quot;)
   *    .in(&quot;address&quot;)
   *      .set(&quot;street&quot;, &quot;12 Revolutionary Rd.&quot;)
   *      .set(&quot;state&quot;, &quot;CA&quot;)
   *      .up(&quot;person&quot;)
   *    .set(&quot;dateOfBirth&quot;, LocalDate.of(1967, 4, 4))
   *  .createMap();
   * }&lt;/pre&gt;&lt;/blockquote&gt;
   *
   * &lt;p&gt;You can chain {@code exit} calls. To exit from a map directly under the root
   * map, specify {@code null} or {@code &quot;&quot;} (an empty string):
   *
   * &lt;blockquote&gt;&lt;pre&gt;{@code
   * MapBuilder mb = new MapBuilder();
   *  .in(&quot;department.manager.address&quot;)
   *    .set(&quot;street&quot;, &quot;Sunset Blvd&quot;)
   *    .up(&quot;manager&quot;)
   *    .up(&quot;department&quot;)
   *    .up(null)
   *  .set(&quot;foo&quot;, &quot;bar&quot;);
   * }&lt;/pre&gt;&lt;/blockquote&gt;
   *
   * @param parent the name of the parent map
   * @return a {@code MapBuilder} for the parent map of the map currently being
   *     written to
   */
  public MapBuilder up(String parent) {
<span class="fc" id="L273">    Check.on(STATE, this.parent).is(notNull(), ERR_HOME_ALREADY);</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">    if (root.size() == 1) {</span>
<span class="fc" id="L275">      Check.that(parent).is(empty(),</span>
          &quot;specify null or \&quot;\&quot; to exit to root map&quot;);
    } else {
<span class="fc" id="L278">      String actual = this.parent.root.segment(-1);</span>
<span class="fc" id="L279">      Check.that(parent).is(EQ(), actual,</span>
          &quot;expected segment: \&quot;${obj}\&quot;; provided segment: \&quot;${arg}\&quot;&quot;);
    }
<span class="fc" id="L282">    return this.parent;</span>
  }

  /**
   * Takes you back to the root map. All paths you specify will be interpreted as
   * absolute paths again.
   *
   * @return a {@code MapBuilder} for the root map
   */
  public MapBuilder reset() {
<span class="fc" id="L292">    Check.on(STATE, parent).is(notNull(), ERR_HOME_ALREADY);</span>
<span class="fc" id="L293">    MapBuilder mb = parent;</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">    while (mb.parent != null) {</span>
<span class="fc" id="L295">      mb = mb.parent;</span>
    }
<span class="fc" id="L297">    return mb;</span>
  }

  /**
   * Returns the current branch within tree of nested {@code Map} objects. That is,
   * the base path relative to which all paths are taken.
   *
   * @return the current branch within tree of nested {@code Map} objects
   */
  public String where() {
<span class="fc" id="L307">    return root.toString();</span>
  }

  /**
   * Returns whether the specified path is set to a terminal value (and hence cannot
   * be extended).
   *
   * @param path the path
   * @return whether it is set to a terminal value
   */
  public boolean isSet(String path) {
<span class="fc" id="L318">    Check.notNull(path);</span>
<span class="fc" id="L319">    return isSet(this, Path.from(path));</span>
  }

  /**
   * Unsets the value of the specified path. If any segment preceding the last
   * segment has a terminal value, or if it is not a key in the map at that point the
   * path, this method returns quietly. If the last segment &lt;i&gt;is&lt;/i&gt; a key, it will
   * be removed.
   *
   * @param path the path to unset.
   * @return this {@code MapBuilder}
   */
  public MapBuilder unset(String path) {
<span class="fc" id="L332">    Check.notNull(path);</span>
<span class="fc" id="L333">    unset(this, Path.from(path));</span>
<span class="fc" id="L334">    return this;</span>
  }

  /**
   * Returns the {@code Map} resulting from the write actions. The returned map is
   * modifiable and retains the order in which the paths (now keys) were written. You
   * can continue to use the {@code MapBuilder} after a call to this method.
   *
   * @return the {@code Map} resulting from the write actions
   */
  public Map&lt;String, Object&gt; createMap() {
<span class="fc" id="L345">    return createMap(this);</span>
  }

  /**
   * Returns a string representation of the map created thus far.
   *
   * @return a string representation of the map created thus far
   */
  @Override
  public String toString() {
<span class="fc" id="L355">    return createMap().toString();</span>
  }

  @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
  private static void init(MapBuilder writer, Map map) {
<span class="fc" id="L360">    map.forEach((key, val) -&gt; processEntry(writer, key, val));</span>
<span class="fc" id="L361">  }</span>

  @SuppressWarnings(&quot;rawtypes&quot;)
  private static void processEntry(MapBuilder writer, Object key, Object val) {
<span class="fc" id="L365">    Check.that(key)</span>
<span class="fc" id="L366">        .isNot(NULL(), &quot;illegal null key in source map&quot;)</span>
<span class="fc" id="L367">        .isNot(empty(), &quot;illegal empty key in source map&quot;)</span>
<span class="fc" id="L368">        .is(instanceOf(), String.class, &quot;illegal key type in source map: ${type}&quot;);</span>
<span class="fc" id="L369">    String k = key.toString();</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">    if (val instanceof Map nested) {</span>
<span class="fc" id="L371">      Path path = writer.root.append(k);</span>
<span class="fc" id="L372">      MapBuilder mb = new MapBuilder(path, writer);</span>
<span class="fc" id="L373">      writer.map.put(k, mb);</span>
<span class="fc" id="L374">      init(mb, nested);</span>
<span class="fc" id="L375">    } else {</span>
<span class="fc" id="L376">      Check.that(val).isNot(instanceOf(), MapBuilder.class); // stifle nasty usage</span>
<span class="fc" id="L377">      writer.map.put(k, ifNull(val, _NULL_));</span>
    }
<span class="fc" id="L379">  }</span>

  private static void set(MapBuilder writer, Path path, Object val) {
<span class="fc" id="L382">    String key = firstSegment(path);</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">    if (path.size() == 1) {</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">      if (writer.map.containsKey(key)) {</span>
<span class="fc" id="L385">        throw alreadySet(writer, key);</span>
      }
<span class="fc" id="L387">      Check.that(val, Param.VALUE)</span>
<span class="fc" id="L388">          .isNot(instanceOf(), Map.class)</span>
<span class="fc" id="L389">          .isNot(instanceOf(), MapBuilder.class); // stifle nasty usage</span>
<span class="fc" id="L390">      writer.map.put(key, ifNull(val, _NULL_));</span>
    } else {
<span class="fc" id="L392">      set(getNestedWriter(writer, key), path.shift(), val);</span>
    }
<span class="fc" id="L394">  }</span>

  private static Result&lt;Object&gt; poll(MapBuilder writer, Path path) {
<span class="fc" id="L397">    String key = path.segment(0);</span>
<span class="fc" id="L398">    Object val = writer.map.get(key);</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">    if (val instanceof MapBuilder nested) {</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">      if (path.size() == 1) {</span>
<span class="fc" id="L401">        return Result.of(nested.createMap());</span>
      }
<span class="fc" id="L403">      return poll(nested, path.shift());</span>
<span class="fc bfc" id="L404" title="All 4 branches covered.">    } else if (path.size() == 1 &amp;&amp; val != null) {</span>
<span class="fc" id="L405">      return Result.of(replaceIf(val, sameAs(), _NULL_, null));</span>
    }
<span class="fc" id="L407">    return Result.notAvailable();</span>
  }

  private static MapBuilder in(MapBuilder writer, Path path) {
<span class="fc bfc" id="L411" title="All 2 branches covered.">    if (path.isEmpty()) {</span>
<span class="fc" id="L412">      return writer;</span>
    }
<span class="fc" id="L414">    String key = firstSegment(path);</span>
<span class="fc" id="L415">    return in(getNestedWriter(writer, key), path.shift());</span>
  }

  private static boolean isSet(MapBuilder writer, Path path) {
<span class="fc" id="L419">    String key = firstSegment(path);</span>
<span class="fc" id="L420">    Object val = writer.map.get(key);</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">    if (val == null) {</span>
<span class="fc" id="L422">      return false;</span>
<span class="fc bfc" id="L423" title="All 4 branches covered.">    } else if (path.size() == 1 || !(val instanceof MapBuilder)) {</span>
<span class="fc" id="L424">      return true;</span>
    }
<span class="fc" id="L426">    return isSet((MapBuilder) val, path.shift());</span>
  }

  private static void unset(MapBuilder writer, Path path) {
<span class="fc" id="L430">    String key = firstSegment(path);</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">    if (path.size() == 1) {</span>
<span class="fc" id="L432">      writer.map.remove(key);</span>
    } else {
<span class="fc" id="L434">      unset(getNestedWriter(writer, key), path.shift());</span>
    }
<span class="fc" id="L436">  }</span>

  private static Map&lt;String, Object&gt; createMap(MapBuilder writer) {
<span class="fc" id="L439">    int sz = 1 + 4 * writer.map.size() / 3;</span>
<span class="fc" id="L440">    Map&lt;String, Object&gt; m = new LinkedHashMap&lt;&gt;(sz);</span>
<span class="fc" id="L441">    writer.map.forEach((key, val) -&gt; {</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">      if (val instanceof MapBuilder mb) {</span>
<span class="fc" id="L443">        m.put(key, createMap(mb));</span>
      } else {
<span class="fc" id="L445">        m.put(key, replaceIf(val, sameAs(), _NULL_, null));</span>
      }
<span class="fc" id="L447">    });</span>
<span class="fc" id="L448">    return m;</span>
  }

  private static MapBuilder getNestedWriter(MapBuilder writer, String key) {
<span class="fc" id="L452">    Path root = writer.root.append(key);</span>
<span class="fc" id="L453">    Object val = writer.map.computeIfAbsent(key, k -&gt; new MapBuilder(root, writer));</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">    if (val instanceof MapBuilder mb) {</span>
<span class="fc" id="L455">      return mb;</span>
    }
<span class="fc" id="L457">    throw new PathBlockedException(root, val);</span>
  }

  private static PathBlockedException alreadySet(MapBuilder writer,
      String key) {
<span class="fc" id="L462">    Path absPath = writer.root.append(key);</span>
<span class="fc" id="L463">    Object curVal = writer.map.get(key);</span>
<span class="fc" id="L464">    return new PathBlockedException(absPath, curVal);</span>
  }

  private static String firstSegment(Path path) {
<span class="fc" id="L468">    return Check.that(path.segment(0))</span>
<span class="fc" id="L469">        .isNot(NULL(), &quot;illegal null segment in path \&quot;${0}\&quot;&quot;, path)</span>
<span class="fc" id="L470">        .has(strlen(), gt(), 0, &quot;illegal empty segment in path \&quot;${0}\&quot;&quot;, path)</span>
<span class="fc" id="L471">        .ok();</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>